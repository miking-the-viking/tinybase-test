import React, {useContext as useContext$1} from 'react';

const getTypeOf = (thing) => typeof thing;
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const LISTENER = 'Listener';
const GET = 'get';
const ADD = 'add';
const TABLES = 'Tables';
const TABLE_IDS = 'TableIds';
const TABLE = 'Table';
const ROW_IDS = 'RowIds';
const SORTED_ROW_IDS = 'SortedRowIds';
const ROW = 'Row';
const CELL_IDS = 'CellIds';
const CELL = 'Cell';
const VALUES = 'Values';
const VALUE_IDS = 'ValueIds';
const VALUE = 'Value';

const arrayMap = (array, cb) => array.map(cb);
const arrayLength = (array) => array.length;
const arrayIsEmpty = (array) => arrayLength(array) == 0;

const isUndefined = (thing) => thing == void 0;
const ifNotUndefined = (value, then, otherwise) =>
  isUndefined(value) ? otherwise?.() : then(value);
const isString = (thing) => getTypeOf(thing) == STRING;
const isArray = (thing) => Array.isArray(thing);
const getUndefined = () => void 0;

const objGet = (obj, id) => ifNotUndefined(obj, (obj2) => obj2[id]);

const {createContext, useContext} = React;
const Context = createContext([]);
const useThing = (id, offset) => {
  const contextValue = useContext(Context);
  return isUndefined(id)
    ? contextValue[offset]
    : isString(id)
    ? objGet(contextValue[offset + 1], id)
    : id;
};
const useThingOrThingId = (thingOrThingId, offset) => {
  const thing = useThing(thingOrThingId, offset);
  return isUndefined(thingOrThingId) || isString(thingOrThingId)
    ? thing
    : thingOrThingId;
};
const useStore = (id) => useThing(id, 0);
const useMetrics = (id) => useThing(id, 2);
const useIndexes = (id) => useThing(id, 4);
const useRelationships = (id) => useThing(id, 6);
const useQueries = (id) => useThing(id, 8);
const useCheckpoints = (id) => useThing(id, 10);
const useStoreOrStoreId = (storeOrStoreId) =>
  useThingOrThingId(storeOrStoreId, 0);
const useMetricsOrMetricsId = (metricsOrMetricsId) =>
  useThingOrThingId(metricsOrMetricsId, 2);
const useIndexesOrIndexesId = (indexesOrIndexesId) =>
  useThingOrThingId(indexesOrIndexesId, 4);
const useRelationshipsOrRelationshipsId = (relationshipsOrRelationshipsId) =>
  useThingOrThingId(relationshipsOrRelationshipsId, 6);
const useQueriesOrQueriesId = (queriesOrQueriesId) =>
  useThingOrThingId(queriesOrQueriesId, 8);
const useCheckpointsOrCheckpointsId = (checkpointsOrCheckpointsId) =>
  useThingOrThingId(checkpointsOrCheckpointsId, 10);

const {useCallback, useEffect, useMemo: useMemo$1, useRef, useState} = React;
const useCreate = (store, create, createDeps = []) => {
  const thing = useMemo$1(
    () => create(store),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store, ...createDeps],
  );
  useEffect(() => () => thing.destroy(), [thing]);
  return thing;
};
const useListenable = (
  listenable,
  thing,
  defaulted,
  args = [],
  getFromListenerArg,
) => {
  const [, rerender] = useState();
  const getResult = useCallback(
    () => thing?.[GET + listenable]?.(...args) ?? defaulted,
    /* eslint-disable-next-line react-hooks/exhaustive-deps */
    [thing, ...args],
  );
  const [initialResult] = useState(getResult);
  const result = useRef(initialResult);
  useMemo$1(() => (result.current = getResult()), [getResult]);
  useListener(
    listenable,
    thing,
    (...listenerArgs) => {
      result.current = isUndefined(getFromListenerArg)
        ? getResult()
        : listenerArgs[getFromListenerArg];
      rerender([]);
    },
    [],
    args,
  );
  return result.current;
};
const useListener = (
  listenable,
  thing,
  listener,
  listenerDeps = [],
  preArgs = [],
  ...postArgs
) =>
  useEffect(() => {
    const listenerId = thing?.[ADD + listenable + LISTENER]?.(
      ...preArgs,
      listener,
      ...postArgs,
    );
    return () => thing?.delListener(listenerId);
  }, [thing, ...preArgs, ...listenerDeps, ...postArgs]);
const useSetCallback = (
  storeOrStoreId,
  settable,
  get,
  getDeps = [],
  then = getUndefined,
  thenDeps = [],
  ...args
) => {
  const store = useStoreOrStoreId(storeOrStoreId);
  return useCallback(
    (parameter) =>
      ifNotUndefined(store, (store2) =>
        ifNotUndefined(get(parameter, store2), (value) =>
          then(store2['set' + settable](...args, value), value),
        ),
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store, settable, ...getDeps, ...thenDeps, ...args],
  );
};
const useDel = (
  storeOrStoreId,
  deletable,
  then = getUndefined,
  thenDeps = [],
  ...args
) => {
  const store = useStoreOrStoreId(storeOrStoreId);
  return useCallback(
    () => then(store?.['del' + deletable](...args)),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store, deletable, ...thenDeps, ...args],
  );
};
const useCheckpointAction = (checkpointsOrCheckpointsId, action, arg) => {
  const checkpoints = useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId);
  return useCallback(
    () => checkpoints?.[action](arg),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [checkpoints, action, arg],
  );
};
const useCreateStore = (create, createDeps = []) =>
  useMemo$1(create, createDeps);
const useTables = (storeOrStoreId) =>
  useListenable(TABLES, useStoreOrStoreId(storeOrStoreId), {});
const useTableIds = (storeOrStoreId) =>
  useListenable(TABLE_IDS, useStoreOrStoreId(storeOrStoreId), [], []);
const useTable = (tableId, storeOrStoreId) =>
  useListenable(TABLE, useStoreOrStoreId(storeOrStoreId), {}, [tableId]);
const useRowIds = (tableId, storeOrStoreId) =>
  useListenable(ROW_IDS, useStoreOrStoreId(storeOrStoreId), [], [tableId]);
const useSortedRowIds = (
  tableId,
  cellId,
  descending,
  offset = 0,
  limit,
  storeOrStoreId,
) =>
  useListenable(
    SORTED_ROW_IDS,
    useStoreOrStoreId(storeOrStoreId),
    [],
    [tableId, cellId, descending, offset, limit],
    6,
  );
const useRow = (tableId, rowId, storeOrStoreId) =>
  useListenable(ROW, useStoreOrStoreId(storeOrStoreId), {}, [tableId, rowId]);
const useCellIds = (tableId, rowId, storeOrStoreId) =>
  useListenable(
    CELL_IDS,
    useStoreOrStoreId(storeOrStoreId),
    [],
    [tableId, rowId],
  );
const useCell = (tableId, rowId, cellId, storeOrStoreId) =>
  useListenable(
    CELL,
    useStoreOrStoreId(storeOrStoreId),
    void 0,
    [tableId, rowId, cellId],
    4,
  );
const useValues = (storeOrStoreId) =>
  useListenable(VALUES, useStoreOrStoreId(storeOrStoreId), {});
const useValueIds = (storeOrStoreId) =>
  useListenable(VALUE_IDS, useStoreOrStoreId(storeOrStoreId), [], []);
const useValue = (valueId, storeOrStoreId) =>
  useListenable(VALUE, useStoreOrStoreId(storeOrStoreId), void 0, [valueId]);
const useSetTablesCallback = (
  getTables,
  getTablesDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    TABLES,
    getTables,
    getTablesDeps,
    then,
    thenDeps,
  );
const useSetTableCallback = (
  tableId,
  getTable,
  getTableDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    TABLE,
    getTable,
    getTableDeps,
    then,
    thenDeps,
    tableId,
  );
const useSetRowCallback = (
  tableId,
  rowId,
  getRow,
  getRowDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    ROW,
    getRow,
    getRowDeps,
    then,
    thenDeps,
    tableId,
    rowId,
  );
const useAddRowCallback = (
  tableId,
  getRow,
  getRowDeps = [],
  storeOrStoreId,
  then = getUndefined,
  thenDeps = [],
) => {
  const store = useStoreOrStoreId(storeOrStoreId);
  return useCallback(
    (parameter) =>
      ifNotUndefined(store, (store2) =>
        ifNotUndefined(getRow(parameter, store2), (row) =>
          then(store2.addRow(tableId, row), store2, row),
        ),
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store, tableId, ...getRowDeps, ...thenDeps],
  );
};
const useSetPartialRowCallback = (
  tableId,
  rowId,
  getPartialRow,
  getPartialRowDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    'PartialRow',
    getPartialRow,
    getPartialRowDeps,
    then,
    thenDeps,
    tableId,
    rowId,
  );
const useSetCellCallback = (
  tableId,
  rowId,
  cellId,
  getCell,
  getCellDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    CELL,
    getCell,
    getCellDeps,
    then,
    thenDeps,
    tableId,
    rowId,
    cellId,
  );
const useSetValuesCallback = (
  getValues,
  getValuesDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    VALUES,
    getValues,
    getValuesDeps,
    then,
    thenDeps,
  );
const useSetPartialValuesCallback = (
  getPartialValues,
  getPartialValuesDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    'PartialValues',
    getPartialValues,
    getPartialValuesDeps,
    then,
    thenDeps,
  );
const useSetValueCallback = (
  valueId,
  getValue,
  getValueDeps,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useSetCallback(
    storeOrStoreId,
    VALUE,
    getValue,
    getValueDeps,
    then,
    thenDeps,
    valueId,
  );
const useDelTablesCallback = (storeOrStoreId, then, thenDeps) =>
  useDel(storeOrStoreId, TABLES, then, thenDeps);
const useDelTableCallback = (tableId, storeOrStoreId, then, thenDeps) =>
  useDel(storeOrStoreId, TABLE, then, thenDeps, tableId);
const useDelRowCallback = (tableId, rowId, storeOrStoreId, then, thenDeps) =>
  useDel(storeOrStoreId, ROW, then, thenDeps, tableId, rowId);
const useDelCellCallback = (
  tableId,
  rowId,
  cellId,
  forceDel,
  storeOrStoreId,
  then,
  thenDeps,
) =>
  useDel(
    storeOrStoreId,
    CELL,
    then,
    thenDeps,
    tableId,
    rowId,
    cellId,
    forceDel,
  );
const useDelValuesCallback = (storeOrStoreId, then, thenDeps) =>
  useDel(storeOrStoreId, VALUES, then, thenDeps);
const useDelValueCallback = (valueId, storeOrStoreId, then, thenDeps) =>
  useDel(storeOrStoreId, VALUE, then, thenDeps, valueId);
const useTablesListener = (listener, listenerDeps, mutator, storeOrStoreId) =>
  useListener(
    TABLES,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [],
    mutator,
  );
const useTableIdsListener = (listener, listenerDeps, mutator, storeOrStoreId) =>
  useListener(
    TABLE_IDS,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [],
    mutator,
  );
const useTableListener = (
  tableId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    TABLE,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId],
    mutator,
  );
const useRowIdsListener = (
  tableId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    ROW_IDS,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId],
    mutator,
  );
const useSortedRowIdsListener = (
  tableId,
  cellId,
  descending,
  offset,
  limit,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    SORTED_ROW_IDS,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId, cellId, descending, offset, limit],
    mutator,
  );
const useRowListener = (
  tableId,
  rowId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    ROW,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId, rowId],
    mutator,
  );
const useCellIdsListener = (
  tableId,
  rowId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    CELL_IDS,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId, rowId],
    mutator,
  );
const useCellListener = (
  tableId,
  rowId,
  cellId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    CELL,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [tableId, rowId, cellId],
    mutator,
  );
const useValuesListener = (listener, listenerDeps, mutator, storeOrStoreId) =>
  useListener(
    VALUES,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [],
    mutator,
  );
const useValueIdsListener = (listener, listenerDeps, mutator, storeOrStoreId) =>
  useListener(
    VALUE_IDS,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [],
    mutator,
  );
const useValueListener = (
  valueId,
  listener,
  listenerDeps,
  mutator,
  storeOrStoreId,
) =>
  useListener(
    VALUE,
    useStoreOrStoreId(storeOrStoreId),
    listener,
    listenerDeps,
    [valueId],
    mutator,
  );
const useCreateMetrics = (store, create, createDeps) =>
  useCreate(store, create, createDeps);
const useMetric = (metricId, metricsOrMetricsId) =>
  useListenable('Metric', useMetricsOrMetricsId(metricsOrMetricsId), void 0, [
    metricId,
  ]);
const useMetricListener = (
  metricId,
  listener,
  listenerDeps,
  metricsOrMetricsId,
) =>
  useListener(
    'Metric',
    useMetricsOrMetricsId(metricsOrMetricsId),
    listener,
    listenerDeps,
    [metricId],
  );
const useCreateIndexes = (store, create, createDeps) =>
  useCreate(store, create, createDeps);
const useSliceIds = (indexId, indexesOrIndexesId) =>
  useListenable(
    'SliceIds',
    useIndexesOrIndexesId(indexesOrIndexesId),
    [],
    [indexId],
  );
const useSliceRowIds = (indexId, sliceId, indexesOrIndexesId) =>
  useListenable(
    'SliceRowIds',
    useIndexesOrIndexesId(indexesOrIndexesId),
    [],
    [indexId, sliceId],
  );
const useSliceIdsListener = (
  indexId,
  listener,
  listenerDeps,
  indexesOrIndexesId,
) =>
  useListener(
    'SliceIds',
    useIndexesOrIndexesId(indexesOrIndexesId),
    listener,
    listenerDeps,
    [indexId],
  );
const useSliceRowIdsListener = (
  indexId,
  sliceId,
  listener,
  listenerDeps,
  indexesOrIndexesId,
) =>
  useListener(
    'SliceRowIds',
    useIndexesOrIndexesId(indexesOrIndexesId),
    listener,
    listenerDeps,
    [indexId, sliceId],
  );
const useCreateRelationships = (store, create, createDeps) =>
  useCreate(store, create, createDeps);
const useRemoteRowId = (
  relationshipId,
  localRowId,
  relationshipsOrRelationshipsId,
) =>
  useListenable(
    'RemoteRowId',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    void 0,
    [relationshipId, localRowId],
  );
const useLocalRowIds = (
  relationshipId,
  remoteRowId,
  relationshipsOrRelationshipsId,
) =>
  useListenable(
    'LocalRowIds',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    [],
    [relationshipId, remoteRowId],
  );
const useLinkedRowIds = (
  relationshipId,
  firstRowId,
  relationshipsOrRelationshipsId,
) =>
  useListenable(
    'LinkedRowIds',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    [],
    [relationshipId, firstRowId],
  );
const useRemoteRowIdListener = (
  relationshipId,
  localRowId,
  listener,
  listenerDeps,
  relationshipsOrRelationshipsId,
) =>
  useListener(
    'RemoteRowId',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    listener,
    listenerDeps,
    [relationshipId, localRowId],
  );
const useLocalRowIdsListener = (
  relationshipId,
  remoteRowId,
  listener,
  listenerDeps,
  relationshipsOrRelationshipsId,
) =>
  useListener(
    'LocalRowIds',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    listener,
    listenerDeps,
    [relationshipId, remoteRowId],
  );
const useLinkedRowIdsListener = (
  relationshipId,
  firstRowId,
  listener,
  listenerDeps,
  relationshipsOrRelationshipsId,
) =>
  useListener(
    'LinkedRowIds',
    useRelationshipsOrRelationshipsId(relationshipsOrRelationshipsId),
    listener,
    listenerDeps,
    [relationshipId, firstRowId],
  );
const useCreateQueries = (store, create, createDeps) =>
  useCreate(store, create, createDeps);
const useResultTable = (queryId, queriesOrQueriesId) =>
  useListenable('ResultTable', useQueriesOrQueriesId(queriesOrQueriesId), {}, [
    queryId,
  ]);
const useResultRowIds = (queryId, queriesOrQueriesId) =>
  useListenable(
    'ResultRowIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    [],
    [queryId],
  );
const useResultSortedRowIds = (
  queryId,
  cellId,
  descending,
  offset = 0,
  limit,
  queriesOrQueriesId,
) =>
  useListenable(
    'ResultSortedRowIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    [],
    [queryId, cellId, descending, offset, limit],
    6,
  );
const useResultRow = (queryId, rowId, queriesOrQueriesId) =>
  useListenable('ResultRow', useQueriesOrQueriesId(queriesOrQueriesId), {}, [
    queryId,
    rowId,
  ]);
const useResultCellIds = (queryId, rowId, queriesOrQueriesId) =>
  useListenable(
    'ResultCellIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    [],
    [queryId, rowId],
  );
const useResultCell = (queryId, rowId, cellId, queriesOrQueriesId) =>
  useListenable(
    'ResultCell',
    useQueriesOrQueriesId(queriesOrQueriesId),
    void 0,
    [queryId, rowId, cellId],
  );
const useResultTableListener = (
  queryId,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultTable',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId],
  );
const useResultRowIdsListener = (
  queryId,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultRowIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId],
  );
const useResultSortedRowIdsListener = (
  queryId,
  cellId,
  descending,
  offset,
  limit,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultSortedRowIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId, cellId, descending, offset, limit],
  );
const useResultRowListener = (
  queryId,
  rowId,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultRow',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId, rowId],
  );
const useResultCellIdsListener = (
  queryId,
  rowId,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultCellIds',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId, rowId],
  );
const useResultCellListener = (
  queryId,
  rowId,
  cellId,
  listener,
  listenerDeps,
  queriesOrQueriesId,
) =>
  useListener(
    'ResultCell',
    useQueriesOrQueriesId(queriesOrQueriesId),
    listener,
    listenerDeps,
    [queryId, rowId, cellId],
  );
const useCreateCheckpoints = (store, create, createDeps) =>
  useCreate(store, create, createDeps);
const useCheckpointIds = (checkpointsOrCheckpointsId) =>
  useListenable(
    'CheckpointIds',
    useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId),
    [[], void 0, []],
  );
const useCheckpoint = (checkpointId, checkpointsOrCheckpointsId) =>
  useListenable(
    'Checkpoint',
    useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId),
    void 0,
    [checkpointId],
  );
const useSetCheckpointCallback = (
  getCheckpoint = getUndefined,
  getCheckpointDeps = [],
  checkpointsOrCheckpointsId,
  then = getUndefined,
  thenDeps = [],
) => {
  const checkpoints = useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId);
  return useCallback(
    (parameter) =>
      ifNotUndefined(checkpoints, (checkpoints2) => {
        const label = getCheckpoint(parameter);
        then(checkpoints2.addCheckpoint(label), checkpoints2, label);
      }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [checkpoints, ...getCheckpointDeps, ...thenDeps],
  );
};
const useGoBackwardCallback = (checkpointsOrCheckpointsId) =>
  useCheckpointAction(checkpointsOrCheckpointsId, 'goBackward');
const useGoForwardCallback = (checkpointsOrCheckpointsId) =>
  useCheckpointAction(checkpointsOrCheckpointsId, 'goForward');
const useGoToCallback = (
  getCheckpointId,
  getCheckpointIdDeps = [],
  checkpointsOrCheckpointsId,
  then = getUndefined,
  thenDeps = [],
) => {
  const checkpoints = useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId);
  return useCallback(
    (parameter) =>
      ifNotUndefined(checkpoints, (checkpoints2) =>
        ifNotUndefined(getCheckpointId(parameter), (checkpointId) =>
          then(checkpoints2.goTo(checkpointId), checkpointId),
        ),
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [checkpoints, ...getCheckpointIdDeps, ...thenDeps],
  );
};
const useUndoInformation = (checkpointsOrCheckpointsId) => {
  const checkpoints = useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId);
  const [backwardIds, currentId] = useCheckpointIds(checkpoints);
  return [
    !arrayIsEmpty(backwardIds),
    useGoBackwardCallback(checkpoints),
    currentId,
    ifNotUndefined(currentId, (id) => checkpoints?.getCheckpoint(id)) ??
      EMPTY_STRING,
  ];
};
const useRedoInformation = (checkpointsOrCheckpointsId) => {
  const checkpoints = useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId);
  const [, , [forwardId]] = useCheckpointIds(checkpoints);
  return [
    !isUndefined(forwardId),
    useGoForwardCallback(checkpoints),
    forwardId,
    ifNotUndefined(forwardId, (id) => checkpoints?.getCheckpoint(id)) ??
      EMPTY_STRING,
  ];
};
const useCheckpointIdsListener = (
  listener,
  listenerDeps,
  checkpointsOrCheckpointsId,
) =>
  useListener(
    'CheckpointIds',
    useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId),
    listener,
    listenerDeps,
  );
const useCheckpointListener = (
  checkpointId,
  listener,
  listenerDeps,
  checkpointsOrCheckpointsId,
) =>
  useListener(
    'Checkpoint',
    useCheckpointsOrCheckpointsId(checkpointsOrCheckpointsId),
    listener,
    listenerDeps,
    [checkpointId],
  );
const useCreatePersister = (
  store,
  create,
  createDeps = [],
  then,
  thenDeps = [],
) => {
  const [, setDone] = useState();
  const persister = useMemo$1(
    () => create(store),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store, ...createDeps],
  );
  useEffect(
    () => {
      (async () => {
        await then?.(persister);
        setDone(1);
        return;
      })();
      return () => {
        persister.destroy();
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [persister, ...thenDeps],
  );
  return persister;
};

const {createElement, useMemo} = React;
const tableView = (
  {
    tableId,
    store,
    rowComponent: Row = RowView,
    getRowComponentProps,
    separator,
    debugIds,
  },
  rowIds,
) =>
  wrap(
    arrayMap(rowIds, (rowId) =>
      /* @__PURE__ */ createElement(Row, {
        ...getProps(getRowComponentProps, rowId),
        key: rowId,
        tableId,
        rowId,
        store,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    tableId,
  );
const resultTableView = (
  {
    queryId,
    queries,
    resultRowComponent: ResultRow = ResultRowView,
    getResultRowComponentProps,
    separator,
    debugIds,
  },
  rowIds,
) =>
  wrap(
    arrayMap(rowIds, (rowId) =>
      /* @__PURE__ */ createElement(ResultRow, {
        ...getProps(getResultRowComponentProps, rowId),
        key: rowId,
        queryId,
        rowId,
        queries,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    queryId,
  );
const useRelationshipsStoreTableId = (relationships) => {
  const resolvedRelationships =
    useRelationshipsOrRelationshipsId(relationships);
  return [resolvedRelationships, resolvedRelationships?.getStore()];
};
const useComponentPerRow = (
  {
    relationshipId,
    relationships,
    rowComponent: Row = RowView,
    getRowComponentProps,
    separator,
    debugIds,
  },
  getRowIdsHook,
  rowId,
) => {
  const [resolvedRelationships, store] =
    useRelationshipsStoreTableId(relationships);
  const tableId = resolvedRelationships?.getLocalTableId(relationshipId);
  const rowIds = getRowIdsHook(relationshipId, rowId, resolvedRelationships);
  return wrap(
    arrayMap(rowIds, (rowId2) =>
      /* @__PURE__ */ createElement(Row, {
        ...getProps(getRowComponentProps, rowId2),
        key: rowId2,
        tableId,
        rowId: rowId2,
        store,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    rowId,
  );
};
const getUseCheckpointView =
  (getCheckpoints) =>
  ({
    checkpoints,
    checkpointComponent: Checkpoint = CheckpointView,
    getCheckpointComponentProps,
    separator,
    debugIds,
  }) => {
    const resolvedCheckpoints = useCheckpointsOrCheckpointsId(checkpoints);
    return wrap(
      arrayMap(
        getCheckpoints(useCheckpointIds(resolvedCheckpoints)),
        (checkpointId) =>
          /* @__PURE__ */ createElement(Checkpoint, {
            ...getProps(getCheckpointComponentProps, checkpointId),
            key: checkpointId,
            checkpoints: resolvedCheckpoints,
            checkpointId,
            debugIds,
          }),
      ),
      separator,
    );
  };
const getProps = (getProps2, id) =>
  isUndefined(getProps2) ? {} : getProps2(id);
const Provider = ({
  store,
  storesById,
  metrics,
  metricsById,
  indexes,
  indexesById,
  relationships,
  relationshipsById,
  queries,
  queriesById,
  checkpoints,
  checkpointsById,
  children,
}) => {
  const parentValue = useContext$1(Context);
  return /* @__PURE__ */ createElement(
    Context.Provider,
    {
      value: useMemo(
        () => [
          store ?? parentValue[0],
          {...parentValue[1], ...storesById},
          metrics ?? parentValue[2],
          {...parentValue[3], ...metricsById},
          indexes ?? parentValue[4],
          {...parentValue[5], ...indexesById},
          relationships ?? parentValue[6],
          {...parentValue[7], ...relationshipsById},
          queries ?? parentValue[8],
          {...parentValue[9], ...queriesById},
          checkpoints ?? parentValue[10],
          {...parentValue[11], ...checkpointsById},
        ],
        [
          store,
          storesById,
          metrics,
          metricsById,
          indexes,
          indexesById,
          relationships,
          relationshipsById,
          queries,
          queriesById,
          checkpoints,
          checkpointsById,
          parentValue,
        ],
      ),
    },
    children,
  );
};
const wrap = (children, separator, encloseWithId, id) => {
  const separatedChildren =
    isUndefined(separator) || !isArray(children)
      ? children
      : arrayMap(children, (child, c) => (c > 0 ? [separator, child] : child));
  return encloseWithId ? [id, ':{', separatedChildren, '}'] : separatedChildren;
};
const CellView = ({tableId, rowId, cellId, store, debugIds}) =>
  wrap(
    EMPTY_STRING + (useCell(tableId, rowId, cellId, store) ?? EMPTY_STRING),
    void 0,
    debugIds,
    cellId,
  );
const RowView = ({
  tableId,
  rowId,
  store,
  cellComponent: Cell = CellView,
  getCellComponentProps,
  separator,
  debugIds,
}) =>
  wrap(
    arrayMap(useCellIds(tableId, rowId, store), (cellId) =>
      /* @__PURE__ */ createElement(Cell, {
        ...getProps(getCellComponentProps, cellId),
        key: cellId,
        tableId,
        rowId,
        cellId,
        store,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    rowId,
  );
const TableView = (props) =>
  tableView(props, useRowIds(props.tableId, props.store));
const SortedTableView = ({cellId, descending, offset, limit, ...props}) =>
  tableView(
    props,
    useSortedRowIds(
      props.tableId,
      cellId,
      descending,
      offset,
      limit,
      props.store,
    ),
  );
const TablesView = ({
  store,
  tableComponent: Table = TableView,
  getTableComponentProps,
  separator,
  debugIds,
}) =>
  wrap(
    arrayMap(useTableIds(store), (tableId) =>
      /* @__PURE__ */ createElement(Table, {
        ...getProps(getTableComponentProps, tableId),
        key: tableId,
        tableId,
        store,
        debugIds,
      }),
    ),
    separator,
  );
const ValueView = ({valueId, store, debugIds}) =>
  wrap(
    EMPTY_STRING + (useValue(valueId, store) ?? EMPTY_STRING),
    void 0,
    debugIds,
    valueId,
  );
const ValuesView = ({
  store,
  valueComponent: Value = ValueView,
  getValueComponentProps,
  separator,
  debugIds,
}) =>
  wrap(
    arrayMap(useValueIds(store), (valueId) =>
      /* @__PURE__ */ createElement(Value, {
        ...getProps(getValueComponentProps, valueId),
        key: valueId,
        valueId,
        store,
        debugIds,
      }),
    ),
    separator,
  );
const MetricView = ({metricId, metrics, debugIds}) =>
  wrap(
    useMetric(metricId, metrics) ?? EMPTY_STRING,
    void 0,
    debugIds,
    metricId,
  );
const SliceView = ({
  indexId,
  sliceId,
  indexes,
  rowComponent: Row = RowView,
  getRowComponentProps,
  separator,
  debugIds,
}) => {
  const resolvedIndexes = useIndexesOrIndexesId(indexes);
  const store = resolvedIndexes?.getStore();
  const tableId = resolvedIndexes?.getTableId(indexId);
  const rowIds = useSliceRowIds(indexId, sliceId, resolvedIndexes);
  return wrap(
    arrayMap(rowIds, (rowId) =>
      /* @__PURE__ */ createElement(Row, {
        ...getProps(getRowComponentProps, rowId),
        key: rowId,
        tableId,
        rowId,
        store,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    sliceId,
  );
};
const IndexView = ({
  indexId,
  indexes,
  sliceComponent: Slice = SliceView,
  getSliceComponentProps,
  separator,
  debugIds,
}) =>
  wrap(
    arrayMap(useSliceIds(indexId, indexes), (sliceId) =>
      /* @__PURE__ */ createElement(Slice, {
        ...getProps(getSliceComponentProps, sliceId),
        key: sliceId,
        indexId,
        sliceId,
        indexes,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    indexId,
  );
const RemoteRowView = ({
  relationshipId,
  localRowId,
  relationships,
  rowComponent: Row = RowView,
  getRowComponentProps,
  debugIds,
}) => {
  const [resolvedRelationships, store] =
    useRelationshipsStoreTableId(relationships);
  const tableId = resolvedRelationships?.getRemoteTableId(relationshipId);
  const rowId = useRemoteRowId(
    relationshipId,
    localRowId,
    resolvedRelationships,
  );
  return wrap(
    isUndefined(tableId) || isUndefined(rowId)
      ? null
      : /* @__PURE__ */ createElement(Row, {
          ...getProps(getRowComponentProps, rowId),
          key: rowId,
          tableId,
          rowId,
          store,
          debugIds,
        }),
    void 0,
    debugIds,
    localRowId,
  );
};
const LocalRowsView = (props) =>
  useComponentPerRow(props, useLocalRowIds, props.remoteRowId);
const LinkedRowsView = (props) =>
  useComponentPerRow(props, useLinkedRowIds, props.firstRowId);
const ResultCellView = ({queryId, rowId, cellId, queries, debugIds}) =>
  wrap(
    EMPTY_STRING +
      (useResultCell(queryId, rowId, cellId, queries) ?? EMPTY_STRING),
    void 0,
    debugIds,
    cellId,
  );
const ResultRowView = ({
  queryId,
  rowId,
  queries,
  resultCellComponent: ResultCell = ResultCellView,
  getResultCellComponentProps,
  separator,
  debugIds,
}) =>
  wrap(
    arrayMap(useResultCellIds(queryId, rowId, queries), (cellId) =>
      /* @__PURE__ */ createElement(ResultCell, {
        ...getProps(getResultCellComponentProps, cellId),
        key: cellId,
        queryId,
        rowId,
        cellId,
        queries,
        debugIds,
      }),
    ),
    separator,
    debugIds,
    rowId,
  );
const ResultTableView = (props) =>
  resultTableView(props, useResultRowIds(props.queryId, props.queries));
const ResultSortedTableView = ({cellId, descending, offset, limit, ...props}) =>
  resultTableView(
    props,
    useResultSortedRowIds(
      props.queryId,
      cellId,
      descending,
      offset,
      limit,
      props.queries,
    ),
  );
const CheckpointView = ({checkpoints, checkpointId, debugIds}) =>
  wrap(
    useCheckpoint(checkpointId, checkpoints) ?? EMPTY_STRING,
    void 0,
    debugIds,
    checkpointId,
  );
const BackwardCheckpointsView = getUseCheckpointView(
  (checkpointIds) => checkpointIds[0],
);
const CurrentCheckpointView = getUseCheckpointView((checkpointIds) =>
  isUndefined(checkpointIds[1]) ? [] : [checkpointIds[1]],
);
const ForwardCheckpointsView = getUseCheckpointView(
  (checkpointIds) => checkpointIds[2],
);

export {
  BackwardCheckpointsView,
  CellView,
  CheckpointView,
  CurrentCheckpointView,
  ForwardCheckpointsView,
  IndexView,
  LinkedRowsView,
  LocalRowsView,
  MetricView,
  Provider,
  RemoteRowView,
  ResultCellView,
  ResultRowView,
  ResultSortedTableView,
  ResultTableView,
  RowView,
  SliceView,
  SortedTableView,
  TableView,
  TablesView,
  ValueView,
  ValuesView,
  tableView,
  useAddRowCallback,
  useCell,
  useCellIds,
  useCellIdsListener,
  useCellListener,
  useCheckpoint,
  useCheckpointIds,
  useCheckpointIdsListener,
  useCheckpointListener,
  useCheckpoints,
  useCreateCheckpoints,
  useCreateIndexes,
  useCreateMetrics,
  useCreatePersister,
  useCreateQueries,
  useCreateRelationships,
  useCreateStore,
  useDelCellCallback,
  useDelRowCallback,
  useDelTableCallback,
  useDelTablesCallback,
  useDelValueCallback,
  useDelValuesCallback,
  useGoBackwardCallback,
  useGoForwardCallback,
  useGoToCallback,
  useIndexes,
  useLinkedRowIds,
  useLinkedRowIdsListener,
  useLocalRowIds,
  useLocalRowIdsListener,
  useMetric,
  useMetricListener,
  useMetrics,
  useQueries,
  useRedoInformation,
  useRelationships,
  useRemoteRowId,
  useRemoteRowIdListener,
  useResultCell,
  useResultCellIds,
  useResultCellIdsListener,
  useResultCellListener,
  useResultRow,
  useResultRowIds,
  useResultRowIdsListener,
  useResultRowListener,
  useResultSortedRowIds,
  useResultSortedRowIdsListener,
  useResultTable,
  useResultTableListener,
  useRow,
  useRowIds,
  useRowIdsListener,
  useRowListener,
  useSetCellCallback,
  useSetCheckpointCallback,
  useSetPartialRowCallback,
  useSetPartialValuesCallback,
  useSetRowCallback,
  useSetTableCallback,
  useSetTablesCallback,
  useSetValueCallback,
  useSetValuesCallback,
  useSliceIds,
  useSliceIdsListener,
  useSliceRowIds,
  useSliceRowIdsListener,
  useSortedRowIds,
  useSortedRowIdsListener,
  useStore,
  useTable,
  useTableIds,
  useTableIdsListener,
  useTableListener,
  useTables,
  useTablesListener,
  useUndoInformation,
  useValue,
  useValueIds,
  useValueIdsListener,
  useValueListener,
  useValues,
  useValuesListener,
};
