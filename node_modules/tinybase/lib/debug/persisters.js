import {promises, watch} from 'fs';

const EMPTY_STRING = '';
const UTF8 = 'utf8';

const isUndefined = (thing) => thing == void 0;
const ifNotUndefined = (value, then, otherwise) =>
  isUndefined(value) ? otherwise?.() : then(value);

const object = Object;
const objFreeze = object.freeze;

const createCustomPersister = (
  store,
  getPersisted,
  setPersisted,
  startListeningToPersisted,
  stopListeningToPersisted,
) => {
  let tablesListenerId;
  let valuesListenerId;
  let loadSave = 0;
  let loads = 0;
  let saves = 0;
  const persister = {
    load: async (initialTables, initialValues) => {
      /* istanbul ignore else */
      if (loadSave != 2) {
        loadSave = 1;
        {
          loads++;
        }
        const body = await getPersisted();
        if (!isUndefined(body) && body != EMPTY_STRING) {
          store.setJson(body);
        } else {
          store.transaction(() =>
            store.setTables(initialTables).setValues(initialValues),
          );
        }
        loadSave = 0;
      }
      return persister;
    },
    startAutoLoad: async (initialTables, initialValues) => {
      persister.stopAutoLoad();
      await persister.load(initialTables, initialValues);
      startListeningToPersisted(persister.load);
      return persister;
    },
    stopAutoLoad: () => {
      stopListeningToPersisted();
      return persister;
    },
    save: async () => {
      /* istanbul ignore else */
      if (loadSave != 1) {
        loadSave = 2;
        {
          saves++;
        }
        await setPersisted(store.getJson());
        loadSave = 0;
      }
      return persister;
    },
    startAutoSave: async () => {
      await persister.stopAutoSave().save();
      tablesListenerId = store.addTablesListener(persister.save);
      valuesListenerId = store.addValuesListener(persister.save);
      return persister;
    },
    stopAutoSave: () => {
      ifNotUndefined(tablesListenerId, store.delListener);
      ifNotUndefined(valuesListenerId, store.delListener);
      return persister;
    },
    getStore: () => store,
    destroy: () => persister.stopAutoLoad().stopAutoSave(),
    getStats: () => ({loads, saves}),
  };
  return objFreeze(persister);
};

const STORAGE = 'storage';
const WINDOW = globalThis.window;
const getStoragePersister = (store, storageName, storage) => {
  let listener;
  const getPersisted = async () => storage.getItem(storageName);
  const setPersisted = async (json) => storage.setItem(storageName, json);
  const startListeningToPersisted = (didChange) => {
    listener = (event) => {
      if (event.storageArea === storage && event.key === storageName) {
        didChange();
      }
    };
    WINDOW.addEventListener(STORAGE, listener);
  };
  const stopListeningToPersisted = () => {
    WINDOW.removeEventListener(STORAGE, listener);
    listener = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};
const createLocalPersister = (store, storageName) =>
  getStoragePersister(store, storageName, localStorage);
const createSessionPersister = (store, storageName) =>
  getStoragePersister(store, storageName, sessionStorage);

const createFilePersister = (store, filePath) => {
  let watcher;
  const getPersisted = async () => {
    try {
      return await promises.readFile(filePath, UTF8);
    } catch {}
  };
  const setPersisted = async (json) => {
    try {
      await promises.writeFile(filePath, json, UTF8);
    } catch {}
  };
  const startListeningToPersisted = (didChange) => {
    watcher = watch(filePath, didChange);
  };
  const stopListeningToPersisted = () => {
    watcher?.close();
    watcher = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};

const getETag = (response) => response.headers.get('ETag');
const createRemotePersister = (
  store,
  loadUrl,
  saveUrl,
  autoLoadIntervalSeconds,
) => {
  let interval;
  let lastEtag;
  const getPersisted = async () => {
    const response = await fetch(loadUrl);
    lastEtag = getETag(response);
    return response.text();
  };
  const setPersisted = async (json) =>
    await fetch(saveUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: json,
    });
  const startListeningToPersisted = (didChange) => {
    interval = setInterval(async () => {
      const response = await fetch(loadUrl, {method: 'HEAD'});
      const currentEtag = getETag(response);
      if (
        !isUndefined(lastEtag) &&
        !isUndefined(currentEtag) &&
        currentEtag != lastEtag
      ) {
        lastEtag = currentEtag;
        didChange();
      }
    }, autoLoadIntervalSeconds * 1e3);
  };
  const stopListeningToPersisted = () => {
    ifNotUndefined(interval, clearInterval);
    interval = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};

export {
  createCustomPersister,
  createFilePersister,
  createLocalPersister,
  createRemotePersister,
  createSessionPersister,
};
