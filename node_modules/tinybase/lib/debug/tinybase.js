import {promises, watch} from 'fs';

const getTypeOf = (thing) => typeof thing;
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const BOOLEAN = getTypeOf(true);
const NUMBER = getTypeOf(0);
const FUNCTION = getTypeOf(getTypeOf);
const TYPE = 'type';
const DEFAULT = 'default';
const UTF8 = 'utf8';
const SUM = 'sum';
const AVG = 'avg';
const MIN = 'min';
const MAX = 'max';
const LISTENER = 'Listener';
const RESULT = 'Result';
const GET = 'get';
const ADD = 'add';
const TABLES = 'Tables';
const TABLE_IDS = 'TableIds';
const TABLE = 'Table';
const ROW_IDS = 'RowIds';
const SORTED_ROW_IDS = 'SortedRowIds';
const ROW = 'Row';
const CELL_IDS = 'CellIds';
const CELL = 'Cell';
const VALUES = 'Values';
const VALUE_IDS = 'ValueIds';
const VALUE = 'Value';
const id = (key) => EMPTY_STRING + key;

const arrayHas = (array, value) => array.includes(value);
const arrayEvery = (array, cb) => array.every(cb);
const arrayIsEqual = (array1, array2) =>
  arrayLength(array1) === arrayLength(array2) &&
  arrayEvery(array1, (value1, index) => array2[index] === value1);
const arrayIsSorted = (array, sorter) =>
  arrayEvery(
    array,
    (value, index) => index == 0 || sorter(array[index - 1], value) <= 0,
  );
const arraySort = (array, sorter) => array.sort(sorter);
const arrayForEach = (array, cb) => array.forEach(cb);
const arrayMap = (array, cb) => array.map(cb);
const arraySum = (array) => arrayReduce(array, (i, j) => i + j, 0);
const arrayLength = (array) => array.length;
const arrayIsEmpty = (array) => arrayLength(array) == 0;
const arrayReduce = (array, cb, initial) => array.reduce(cb, initial);
const arrayFilter = (array, cb) => array.filter(cb);
const arraySlice = (array, start, end) => array.slice(start, end);
const arrayClear = (array, to) => array.splice(0, to);
const arrayPush = (array, ...values) => array.push(...values);
const arrayPop = (array) => array.pop();
const arrayUnshift = (array, ...values) => array.unshift(...values);
const arrayShift = (array) => array.shift();

const jsonString = (obj) =>
  JSON.stringify(obj, (_key, value) =>
    isInstanceOf(value, Map)
      ? arrayReduce(
          [...value],
          (obj2, [key, value2]) => {
            obj2[key] = value2;
            return obj2;
          },
          {},
        )
      : value,
  );
const jsonParse = JSON.parse;
const mathMax = Math.max;
const mathMin = Math.min;
const isFiniteNumber = isFinite;
const isInstanceOf = (thing, cls) => thing instanceof cls;
const isUndefined = (thing) => thing == void 0;
const ifNotUndefined = (value, then, otherwise) =>
  isUndefined(value) ? otherwise?.() : then(value);
const isTypeStringOrBoolean = (type) => type == STRING || type == BOOLEAN;
const isString = (thing) => getTypeOf(thing) == STRING;
const isFunction = (thing) => getTypeOf(thing) == FUNCTION;
const isArray = (thing) => Array.isArray(thing);
const test = (regex, subject) => regex.test(subject);
const getUndefined = () => void 0;

const collSizeN = (collSizer) => (coll) =>
  arrayReduce(collValues(coll), (total, coll2) => total + collSizer(coll2), 0);
const collSize = (coll) => coll.size;
const collSize2 = collSizeN(collSize);
const collSize3 = collSizeN(collSize2);
const collSize4 = collSizeN(collSize3);
const collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;
const collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;
const collValues = (coll) => [...(coll?.values() ?? [])];
const collClear = (coll) => coll.clear();
const collForEach = (coll, cb) => coll?.forEach(cb);
const collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);

const mapNew = (entries) => new Map(entries);
const mapKeys = (map) => [...(map?.keys() ?? [])];
const mapGet = (map, key) => map?.get(key);
const mapForEach = (map, cb) =>
  collForEach(map, (value, key) => cb(key, value));
const mapMap = (coll, cb) =>
  arrayMap([...(coll?.entries() ?? [])], ([key, value]) => cb(value, key));
const mapSet = (map, key, value) =>
  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue) => {
  if (!collHas(map, key)) {
    mapSet(map, key, getDefaultValue());
  }
  return mapGet(map, key);
};
const mapToObj = (map, childMapper, childExclude) => {
  const obj = {};
  const mapper = childMapper ?? ((mapValue) => mapValue);
  collForEach(map, (value, key) =>
    ifNotUndefined(mapper(value), (mappedValue) =>
      childExclude?.(mappedValue) ? 0 : (obj[key] = mappedValue),
    ),
  );
  return obj;
};
const mapClone = (map, childMapper) => {
  const map2 = mapNew();
  const mapper = childMapper ?? ((mapValue) => mapValue);
  collForEach(map, (value, key) => map2.set(key, mapper(value)));
  return map2;
};
const mapClone2 = (map) => mapClone(map, mapClone);
const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>
  ifNotUndefined(
    (ensureLeaf ? mapEnsure : mapGet)(
      node,
      path[p],
      p > arrayLength(path) - 2 ? ensureLeaf : mapNew,
    ),
    (nodeOrLeaf) => {
      if (p > arrayLength(path) - 2) {
        if (pruneLeaf?.(nodeOrLeaf)) {
          mapSet(node, path[p]);
        }
        return nodeOrLeaf;
      }
      const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
      if (collIsEmpty(nodeOrLeaf)) {
        mapSet(node, path[p]);
      }
      return leaf;
    },
  );

const getCellOrValueType = (cell) => {
  const type = getTypeOf(cell);
  return isTypeStringOrBoolean(type) || (type == NUMBER && isFiniteNumber(cell))
    ? type
    : void 0;
};
const setOrDelCell = (store, tableId, rowId, cellId, cell) =>
  isUndefined(cell)
    ? store.delCell(tableId, rowId, cellId, true)
    : store.setCell(tableId, rowId, cellId, cell);
const setOrDelValue = (store, valueId, value) =>
  isUndefined(value) ? store.delValue(valueId) : store.setValue(valueId, value);

const setNew = (entryOrEntries) =>
  new Set(
    isArray(entryOrEntries) || isUndefined(entryOrEntries)
      ? entryOrEntries
      : [entryOrEntries],
  );
const setAdd = (set, value) => set?.add(value);

const getDefinableFunctions = (store, getDefaultThing, validateRowValue) => {
  const hasRow = store.hasRow;
  const tableIds = mapNew();
  const things = mapNew();
  const allRowValues = mapNew();
  const allSortKeys = mapNew();
  const storeListenerIds = mapNew();
  const getStore = () => store;
  const getThingIds = () => mapKeys(tableIds);
  const forEachThing = (cb) => mapForEach(things, cb);
  const hasThing = (id) => collHas(things, id);
  const getTableId = (id) => mapGet(tableIds, id);
  const getThing = (id) => mapGet(things, id);
  const setThing = (id, thing) => mapSet(things, id, thing);
  const addStoreListeners = (id, andCall, ...listenerIds) => {
    const set = mapEnsure(storeListenerIds, id, setNew);
    arrayForEach(
      listenerIds,
      (listenerId) =>
        setAdd(set, listenerId) && andCall && store.callListener(listenerId),
    );
    return listenerIds;
  };
  const delStoreListeners = (id, ...listenerIds) =>
    ifNotUndefined(mapGet(storeListenerIds, id), (allListenerIds) => {
      arrayForEach(
        arrayIsEmpty(listenerIds) ? collValues(allListenerIds) : listenerIds,
        (listenerId) => {
          store.delListener(listenerId);
          collDel(allListenerIds, listenerId);
        },
      );
      if (collIsEmpty(allListenerIds)) {
        mapSet(storeListenerIds, id);
      }
    });
  const setDefinition = (id, tableId) => {
    mapSet(tableIds, id, tableId);
    if (!collHas(things, id)) {
      mapSet(things, id, getDefaultThing());
      mapSet(allRowValues, id, mapNew());
      mapSet(allSortKeys, id, mapNew());
    }
  };
  const setDefinitionAndListen = (
    id,
    tableId,
    onChanged,
    getRowValue,
    getSortKey,
  ) => {
    setDefinition(id, tableId);
    const changedRowValues = mapNew();
    const changedSortKeys = mapNew();
    const rowValues = mapGet(allRowValues, id);
    const sortKeys = mapGet(allSortKeys, id);
    const processRow = (rowId) => {
      const getCell = (cellId) => store.getCell(tableId, rowId, cellId);
      const oldRowValue = mapGet(rowValues, rowId);
      const newRowValue = hasRow(tableId, rowId)
        ? validateRowValue(getRowValue(getCell, rowId))
        : void 0;
      if (
        !(
          oldRowValue === newRowValue ||
          (isArray(oldRowValue) &&
            isArray(newRowValue) &&
            arrayIsEqual(oldRowValue, newRowValue))
        )
      ) {
        mapSet(changedRowValues, rowId, [oldRowValue, newRowValue]);
      }
      if (!isUndefined(getSortKey)) {
        const oldSortKey = mapGet(sortKeys, rowId);
        const newSortKey = hasRow(tableId, rowId)
          ? getSortKey(getCell, rowId)
          : void 0;
        if (oldSortKey != newSortKey) {
          mapSet(changedSortKeys, rowId, newSortKey);
        }
      }
    };
    const processTable = (force) => {
      onChanged(
        () => {
          collForEach(changedRowValues, ([, newRowValue], rowId) =>
            mapSet(rowValues, rowId, newRowValue),
          );
          collForEach(changedSortKeys, (newSortKey, rowId) =>
            mapSet(sortKeys, rowId, newSortKey),
          );
        },
        changedRowValues,
        changedSortKeys,
        rowValues,
        sortKeys,
        force,
      );
      collClear(changedRowValues);
      collClear(changedSortKeys);
    };
    mapForEach(rowValues, processRow);
    if (store.hasTable(tableId)) {
      arrayForEach(store.getRowIds(tableId), (rowId) => {
        if (!collHas(rowValues, rowId)) {
          processRow(rowId);
        }
      });
    }
    processTable(true);
    delStoreListeners(id);
    addStoreListeners(
      id,
      0,
      store.addRowListener(tableId, null, (_store, _tableId, rowId) =>
        processRow(rowId),
      ),
      store.addTableListener(tableId, () => processTable()),
    );
  };
  const delDefinition = (id) => {
    mapSet(tableIds, id);
    mapSet(things, id);
    mapSet(allRowValues, id);
    mapSet(allSortKeys, id);
    delStoreListeners(id);
  };
  const destroy = () => mapForEach(storeListenerIds, delDefinition);
  return [
    getStore,
    getThingIds,
    forEachThing,
    hasThing,
    getTableId,
    getThing,
    setThing,
    setDefinition,
    setDefinitionAndListen,
    delDefinition,
    destroy,
    addStoreListeners,
    delStoreListeners,
  ];
};
const getRowCellFunction = (getRowCell, defaultCellValue) =>
  isString(getRowCell)
    ? (getCell) => getCell(getRowCell)
    : getRowCell ?? (() => defaultCellValue ?? EMPTY_STRING);
const getCreateFunction = (getFunction) => {
  const getFunctionsByStore = /* @__PURE__ */ new WeakMap();
  return (store) => {
    if (!getFunctionsByStore.has(store)) {
      getFunctionsByStore.set(store, getFunction(store));
    }
    return getFunctionsByStore.get(store);
  };
};

const INTEGER = /^\d+$/;
const getPoolFunctions = () => {
  const pool = [];
  let nextId = 0;
  return [
    () => arrayShift(pool) ?? EMPTY_STRING + nextId++,
    (id) => {
      if (test(INTEGER, id) && arrayLength(pool) < 1e3) {
        arrayPush(pool, id);
      }
    },
  ];
};

const getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {
  const leaves = [];
  const deep = (node, p) =>
    p == arrayLength(path)
      ? arrayPush(leaves, node)
      : path[p] === null
      ? collForEach(node, (node2) => deep(node2, p + 1))
      : arrayForEach([path[p], null], (id) => deep(mapGet(node, id), p + 1));
  deep(deepIdSet, 0);
  return leaves;
};
const getListenerFunctions = (getThing) => {
  let thing;
  const [getId, releaseId] = getPoolFunctions();
  const allListeners = mapNew();
  const addListener = (
    listener,
    idSetNode,
    path,
    pathGetters = [],
    extraArgsGetter = () => [],
  ) => {
    thing ??= getThing();
    const id = getId();
    mapSet(allListeners, id, [
      listener,
      idSetNode,
      path,
      pathGetters,
      extraArgsGetter,
    ]);
    setAdd(visitTree(idSetNode, path ?? [EMPTY_STRING], setNew), id);
    return id;
  };
  const callListeners = (idSetNode, ids, ...extraArgs) =>
    arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>
      collForEach(set, (id) =>
        mapGet(allListeners, id)[0](thing, ...(ids ?? []), ...extraArgs),
      ),
    );
  const delListener = (id) =>
    ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {
      visitTree(idSetNode, idOrNulls ?? [EMPTY_STRING], void 0, (idSet) => {
        collDel(idSet, id);
        return collIsEmpty(idSet) ? 1 : 0;
      });
      mapSet(allListeners, id);
      releaseId(id);
      return idOrNulls;
    });
  const callListener = (id) =>
    ifNotUndefined(
      mapGet(allListeners, id),
      ([listener, , path = [], pathGetters, extraArgsGetter]) => {
        const callWithIds = (...ids) => {
          const index = arrayLength(ids);
          index == arrayLength(path)
            ? listener(thing, ...ids, ...extraArgsGetter(ids))
            : isUndefined(path[index])
            ? arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2) =>
                callWithIds(...ids, id2),
              )
            : callWithIds(...ids, path[index]);
        };
        callWithIds();
      },
    );
  return [addListener, callListeners, delListener, callListener];
};

const object = Object;
const objIds = object.keys;
const objFrozen = object.isFrozen;
const objFreeze = object.freeze;
const isObject = (obj) =>
  isInstanceOf(obj, object) && obj.constructor == object;
const objGet = (obj, id) => ifNotUndefined(obj, (obj2) => obj2[id]);
const objHas = (obj, id) => !isUndefined(objGet(obj, id));
const objDel = (obj, id) => delete obj[id];
const objMap = (obj, cb) =>
  arrayMap(object.entries(obj), ([id, value]) => cb(value, id));
const objIsEmpty = (obj) => isObject(obj) && arrayIsEmpty(objIds(obj));

const createCheckpoints = getCreateFunction((store) => {
  let backwardIdsSize = 100;
  let currentId;
  let cellsDelta = mapNew();
  let valuesDelta = mapNew();
  let listening = 1;
  let nextCheckpointId;
  let checkpointsChanged;
  const checkpointIdsListeners = mapNew();
  const checkpointListeners = mapNew();
  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(
    () => checkpoints,
  );
  const deltas = mapNew();
  const labels = mapNew();
  const backwardIds = [];
  const forwardIds = [];
  const updateStore = (oldOrNew, checkpointId) => {
    listening = 0;
    store.transaction(() => {
      const [cellsDelta2, valuesDelta2] = mapGet(deltas, checkpointId);
      collForEach(cellsDelta2, (table, tableId) =>
        collForEach(table, (row, rowId) =>
          collForEach(row, (oldNew, cellId) =>
            setOrDelCell(store, tableId, rowId, cellId, oldNew[oldOrNew]),
          ),
        ),
      );
      collForEach(valuesDelta2, (oldNew, valueId) =>
        setOrDelValue(store, valueId, oldNew[oldOrNew]),
      );
    });
    listening = 1;
  };
  const clearCheckpointId = (checkpointId) => {
    mapSet(deltas, checkpointId);
    mapSet(labels, checkpointId);
    callListeners(checkpointListeners, [checkpointId]);
  };
  const clearCheckpointIds = (checkpointIds, to) =>
    arrayForEach(
      arrayClear(checkpointIds, to ?? arrayLength(checkpointIds)),
      clearCheckpointId,
    );
  const trimBackwardsIds = () =>
    clearCheckpointIds(backwardIds, arrayLength(backwardIds) - backwardIdsSize);
  const storeChanged = () =>
    ifNotUndefined(currentId, () => {
      arrayPush(backwardIds, currentId);
      trimBackwardsIds();
      clearCheckpointIds(forwardIds);
      currentId = void 0;
      checkpointsChanged = 1;
    });
  const storeUnchanged = () => {
    currentId = arrayPop(backwardIds);
    checkpointsChanged = 1;
  };
  const cellListenerId = store.addCellListener(
    null,
    null,
    null,
    (_store, tableId, rowId, cellId, newCell, oldCell) => {
      if (listening) {
        storeChanged();
        const table = mapEnsure(cellsDelta, tableId, mapNew);
        const row = mapEnsure(table, rowId, mapNew);
        const oldNew = mapEnsure(row, cellId, () => [oldCell, void 0]);
        oldNew[1] = newCell;
        if (
          oldNew[0] === newCell &&
          collIsEmpty(mapSet(row, cellId)) &&
          collIsEmpty(mapSet(table, rowId)) &&
          collIsEmpty(mapSet(cellsDelta, tableId))
        ) {
          storeUnchanged();
        }
        callListenersIfChanged();
      }
    },
  );
  const valueListenerId = store.addValueListener(
    null,
    (_store, valueId, newValue, oldValue) => {
      if (listening) {
        storeChanged();
        const oldNew = mapEnsure(valuesDelta, valueId, () => [
          oldValue,
          void 0,
        ]);
        oldNew[1] = newValue;
        if (
          oldNew[0] === newValue &&
          collIsEmpty(mapSet(valuesDelta, valueId))
        ) {
          storeUnchanged();
        }
        callListenersIfChanged();
      }
    },
  );
  const addCheckpointImpl = (label = EMPTY_STRING) => {
    if (isUndefined(currentId)) {
      currentId = EMPTY_STRING + nextCheckpointId++;
      mapSet(deltas, currentId, [cellsDelta, valuesDelta]);
      setCheckpoint(currentId, label);
      cellsDelta = mapNew();
      valuesDelta = mapNew();
      checkpointsChanged = 1;
    }
    return currentId;
  };
  const goBackwardImpl = () => {
    if (!arrayIsEmpty(backwardIds)) {
      arrayUnshift(forwardIds, addCheckpointImpl());
      updateStore(0, currentId);
      currentId = arrayPop(backwardIds);
      checkpointsChanged = 1;
    }
  };
  const goForwardImpl = () => {
    if (!arrayIsEmpty(forwardIds)) {
      arrayPush(backwardIds, currentId);
      currentId = arrayShift(forwardIds);
      updateStore(1, currentId);
      checkpointsChanged = 1;
    }
  };
  const callListenersIfChanged = () => {
    if (checkpointsChanged) {
      callListeners(checkpointIdsListeners);
      checkpointsChanged = 0;
    }
  };
  const setSize = (size) => {
    backwardIdsSize = size;
    trimBackwardsIds();
    return checkpoints;
  };
  const addCheckpoint = (label) => {
    const id = addCheckpointImpl(label);
    callListenersIfChanged();
    return id;
  };
  const setCheckpoint = (checkpointId, label) => {
    if (hasCheckpoint(checkpointId) && mapGet(labels, checkpointId) !== label) {
      mapSet(labels, checkpointId, label);
      callListeners(checkpointListeners, [checkpointId]);
    }
    return checkpoints;
  };
  const getStore = () => store;
  const getCheckpointIds = () => [[...backwardIds], currentId, [...forwardIds]];
  const forEachCheckpoint = (checkpointCallback) =>
    mapForEach(labels, checkpointCallback);
  const hasCheckpoint = (checkpointId) => collHas(deltas, checkpointId);
  const getCheckpoint = (checkpointId) => mapGet(labels, checkpointId);
  const goBackward = () => {
    goBackwardImpl();
    callListenersIfChanged();
    return checkpoints;
  };
  const goForward = () => {
    goForwardImpl();
    callListenersIfChanged();
    return checkpoints;
  };
  const goTo = (checkpointId) => {
    const action = arrayHas(backwardIds, checkpointId)
      ? goBackwardImpl
      : arrayHas(forwardIds, checkpointId)
      ? goForwardImpl
      : null;
    while (!isUndefined(action) && checkpointId != currentId) {
      action();
    }
    callListenersIfChanged();
    return checkpoints;
  };
  const addCheckpointIdsListener = (listener) =>
    addListener(listener, checkpointIdsListeners);
  const addCheckpointListener = (checkpointId, listener) =>
    addListener(listener, checkpointListeners, [checkpointId]);
  const delListener = (listenerId) => {
    delListenerImpl(listenerId);
    return checkpoints;
  };
  const clear = () => {
    clearCheckpointIds(backwardIds);
    clearCheckpointIds(forwardIds);
    if (!isUndefined(currentId)) {
      clearCheckpointId(currentId);
    }
    currentId = void 0;
    nextCheckpointId = 0;
    addCheckpoint();
    return checkpoints;
  };
  const destroy = () => {
    store.delListener(cellListenerId);
    store.delListener(valueListenerId);
  };
  const getListenerStats = () => ({
    checkpointIds: collSize2(checkpointIdsListeners),
    checkpoint: collSize2(checkpointListeners),
  });
  const checkpoints = {
    setSize,
    addCheckpoint,
    setCheckpoint,
    getStore,
    getCheckpointIds,
    forEachCheckpoint,
    hasCheckpoint,
    getCheckpoint,
    goBackward,
    goForward,
    goTo,
    addCheckpointIdsListener,
    addCheckpointListener,
    delListener,
    clear,
    destroy,
    getListenerStats,
  };
  return objFreeze(checkpoints.clear());
});

const defaultSorter = (sortKey1, sortKey2) => (sortKey1 < sortKey2 ? -1 : 1);

const createIndexes = getCreateFunction((store) => {
  const sliceIdsListeners = mapNew();
  const sliceRowIdsListeners = mapNew();
  const [
    getStore,
    getIndexIds,
    forEachIndexImpl,
    hasIndex,
    getTableId,
    getIndex,
    setIndex,
    ,
    setDefinitionAndListen,
    delDefinition,
    destroy,
  ] = getDefinableFunctions(store, mapNew, (value) =>
    isUndefined(value)
      ? EMPTY_STRING
      : isArray(value)
      ? arrayMap(value, id)
      : id(value),
  );
  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(
    () => indexes,
  );
  const hasSlice = (indexId, sliceId) => collHas(getIndex(indexId), sliceId);
  const setIndexDefinition = (
    indexId,
    tableId,
    getSliceIdOrIds,
    getSortKey,
    sliceIdSorter,
    rowIdSorter = defaultSorter,
  ) => {
    const sliceIdArraySorter = isUndefined(sliceIdSorter)
      ? void 0
      : ([id1], [id2]) => sliceIdSorter(id1, id2);
    setDefinitionAndListen(
      indexId,
      tableId,
      (change, changedSliceIds, changedSortKeys, sliceIds, sortKeys, force) => {
        let sliceIdsChanged = 0;
        const changedSlices = setNew();
        const unsortedSlices = setNew();
        const index = getIndex(indexId);
        collForEach(
          changedSliceIds,
          ([oldSliceIdOrIds, newSliceIdOrIds], rowId) => {
            const oldSliceIds = setNew(oldSliceIdOrIds);
            const newSliceIds = setNew(newSliceIdOrIds);
            collForEach(oldSliceIds, (oldSliceId) =>
              collDel(newSliceIds, oldSliceId)
                ? collDel(oldSliceIds, oldSliceId)
                : 0,
            );
            collForEach(oldSliceIds, (oldSliceId) => {
              setAdd(changedSlices, oldSliceId);
              ifNotUndefined(mapGet(index, oldSliceId), (oldSlice) => {
                collDel(oldSlice, rowId);
                if (collIsEmpty(oldSlice)) {
                  mapSet(index, oldSliceId);
                  sliceIdsChanged = 1;
                }
              });
            });
            collForEach(newSliceIds, (newSliceId) => {
              setAdd(changedSlices, newSliceId);
              if (!collHas(index, newSliceId)) {
                mapSet(index, newSliceId, setNew());
                sliceIdsChanged = 1;
              }
              setAdd(mapGet(index, newSliceId), rowId);
              if (!isUndefined(getSortKey)) {
                setAdd(unsortedSlices, newSliceId);
              }
            });
          },
        );
        change();
        if (!collIsEmpty(sortKeys)) {
          if (force) {
            mapForEach(index, (sliceId) => setAdd(unsortedSlices, sliceId));
          } else {
            mapForEach(changedSortKeys, (rowId) =>
              ifNotUndefined(mapGet(sliceIds, rowId), (sliceId) =>
                setAdd(unsortedSlices, sliceId),
              ),
            );
          }
          collForEach(unsortedSlices, (sliceId) => {
            const rowIdArraySorter = (rowId1, rowId2) =>
              rowIdSorter(
                mapGet(sortKeys, rowId1),
                mapGet(sortKeys, rowId2),
                sliceId,
              );
            const sliceArray = [...mapGet(index, sliceId)];
            if (!arrayIsSorted(sliceArray, rowIdArraySorter)) {
              mapSet(
                index,
                sliceId,
                setNew(arraySort(sliceArray, rowIdArraySorter)),
              );
              setAdd(changedSlices, sliceId);
            }
          });
        }
        if (sliceIdsChanged || force) {
          if (!isUndefined(sliceIdArraySorter)) {
            const indexArray = [...index];
            if (!arrayIsSorted(indexArray, sliceIdArraySorter)) {
              setIndex(
                indexId,
                mapNew(arraySort(indexArray, sliceIdArraySorter)),
              );
              sliceIdsChanged = 1;
            }
          }
        }
        if (sliceIdsChanged) {
          callListeners(sliceIdsListeners, [indexId]);
        }
        collForEach(changedSlices, (sliceId) =>
          callListeners(sliceRowIdsListeners, [indexId, sliceId]),
        );
      },
      getRowCellFunction(getSliceIdOrIds),
      ifNotUndefined(getSortKey, getRowCellFunction),
    );
    return indexes;
  };
  const forEachIndex = (indexCallback) =>
    forEachIndexImpl((indexId, slices) =>
      indexCallback(indexId, (sliceCallback) =>
        forEachSliceImpl(indexId, sliceCallback, slices),
      ),
    );
  const forEachSlice = (indexId, sliceCallback) =>
    forEachSliceImpl(indexId, sliceCallback, getIndex(indexId));
  const forEachSliceImpl = (indexId, sliceCallback, slices) => {
    const tableId = getTableId(indexId);
    collForEach(slices, (rowIds, sliceId) =>
      sliceCallback(sliceId, (rowCallback) =>
        collForEach(rowIds, (rowId) =>
          rowCallback(rowId, (cellCallback) =>
            store.forEachCell(tableId, rowId, cellCallback),
          ),
        ),
      ),
    );
  };
  const delIndexDefinition = (indexId) => {
    delDefinition(indexId);
    return indexes;
  };
  const getSliceIds = (indexId) => mapKeys(getIndex(indexId));
  const getSliceRowIds = (indexId, sliceId) =>
    collValues(mapGet(getIndex(indexId), sliceId));
  const addSliceIdsListener = (indexId, listener) =>
    addListener(listener, sliceIdsListeners, [indexId]);
  const addSliceRowIdsListener = (indexId, sliceId, listener) =>
    addListener(listener, sliceRowIdsListeners, [indexId, sliceId]);
  const delListener = (listenerId) => {
    delListenerImpl(listenerId);
    return indexes;
  };
  const getListenerStats = () => ({
    sliceIds: collSize2(sliceIdsListeners),
    sliceRowIds: collSize3(sliceRowIdsListeners),
  });
  const indexes = {
    setIndexDefinition,
    delIndexDefinition,
    getStore,
    getIndexIds,
    forEachIndex,
    forEachSlice,
    hasIndex,
    hasSlice,
    getTableId,
    getSliceIds,
    getSliceRowIds,
    addSliceIdsListener,
    addSliceRowIdsListener,
    delListener,
    destroy,
    getListenerStats,
  };
  return objFreeze(indexes);
});

const numericAggregators = mapNew([
  [
    AVG,
    [
      (numbers, length) => arraySum(numbers) / length,
      (metric, add, length) => metric + (add - metric) / (length + 1),
      (metric, remove, length) => metric + (metric - remove) / (length - 1),
      (metric, add, remove, length) => metric + (add - remove) / length,
    ],
  ],
  [
    MAX,
    [
      (numbers) => mathMax(...numbers),
      (metric, add) => mathMax(add, metric),
      (metric, remove) => (remove == metric ? void 0 : metric),
      (metric, add, remove) =>
        remove == metric ? void 0 : mathMax(add, metric),
    ],
  ],
  [
    MIN,
    [
      (numbers) => mathMin(...numbers),
      (metric, add) => mathMin(add, metric),
      (metric, remove) => (remove == metric ? void 0 : metric),
      (metric, add, remove) =>
        remove == metric ? void 0 : mathMin(add, metric),
    ],
  ],
  [
    SUM,
    [
      (numbers) => arraySum(numbers),
      (metric, add) => metric + add,
      (metric, remove) => metric - remove,
      (metric, add, remove) => metric - remove + add,
    ],
  ],
]);
const getAggregateValue = (
  aggregateValue,
  oldLength,
  newValues,
  changedValues,
  aggregators,
  force = false,
) => {
  if (collIsEmpty(newValues)) {
    return void 0;
  }
  const [aggregate, aggregateAdd, aggregateRemove, aggregateReplace] =
    aggregators;
  force ||= isUndefined(aggregateValue);
  collForEach(changedValues, ([oldValue, newValue]) => {
    if (!force) {
      aggregateValue = isUndefined(oldValue)
        ? aggregateAdd?.(aggregateValue, newValue, oldLength++)
        : isUndefined(newValue)
        ? aggregateRemove?.(aggregateValue, oldValue, oldLength--)
        : aggregateReplace?.(aggregateValue, newValue, oldValue, oldLength);
      force ||= isUndefined(aggregateValue);
    }
  });
  return force
    ? aggregate(collValues(newValues), collSize(newValues))
    : aggregateValue;
};

const createMetrics = getCreateFunction((store) => {
  const metricListeners = mapNew();
  const [
    getStore,
    getMetricIds,
    forEachMetric,
    hasMetric,
    getTableId,
    getMetric,
    setMetric,
    ,
    setDefinitionAndListen,
    delDefinition,
    destroy,
  ] = getDefinableFunctions(store, getUndefined, (value) =>
    isNaN(value) ||
    isUndefined(value) ||
    value === true ||
    value === false ||
    value === EMPTY_STRING
      ? void 0
      : value * 1,
  );
  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(
    () => metrics,
  );
  const setMetricDefinition = (
    metricId,
    tableId,
    aggregate,
    getNumber,
    aggregateAdd,
    aggregateRemove,
    aggregateReplace,
  ) => {
    const aggregators = isFunction(aggregate)
      ? [aggregate, aggregateAdd, aggregateRemove, aggregateReplace]
      : mapGet(numericAggregators, aggregate) ??
        mapGet(numericAggregators, SUM);
    setDefinitionAndListen(
      metricId,
      tableId,
      (change, changedNumbers, _changedSortKeys, numbers, _sortKeys, force) => {
        const oldMetric = getMetric(metricId);
        const oldLength = collSize(numbers);
        force ||= isUndefined(oldMetric);
        change();
        let newMetric = getAggregateValue(
          oldMetric,
          oldLength,
          numbers,
          changedNumbers,
          aggregators,
          force,
        );
        if (!isFiniteNumber(newMetric)) {
          newMetric = void 0;
        }
        if (newMetric != oldMetric) {
          setMetric(metricId, newMetric);
          callListeners(metricListeners, [metricId], newMetric, oldMetric);
        }
      },
      getRowCellFunction(getNumber, 1),
    );
    return metrics;
  };
  const delMetricDefinition = (metricId) => {
    delDefinition(metricId);
    return metrics;
  };
  const addMetricListener = (metricId, listener) =>
    addListener(listener, metricListeners, [metricId]);
  const delListener = (listenerId) => {
    delListenerImpl(listenerId);
    return metrics;
  };
  const getListenerStats = () => ({metric: collSize2(metricListeners)});
  const metrics = {
    setMetricDefinition,
    delMetricDefinition,
    getStore,
    getMetricIds,
    forEachMetric,
    hasMetric,
    getTableId,
    getMetric,
    addMetricListener,
    delListener,
    destroy,
    getListenerStats,
  };
  return objFreeze(metrics);
});

const createCustomPersister = (
  store,
  getPersisted,
  setPersisted,
  startListeningToPersisted,
  stopListeningToPersisted,
) => {
  let tablesListenerId;
  let valuesListenerId;
  let loadSave = 0;
  let loads = 0;
  let saves = 0;
  const persister = {
    load: async (initialTables, initialValues) => {
      /* istanbul ignore else */
      if (loadSave != 2) {
        loadSave = 1;
        {
          loads++;
        }
        const body = await getPersisted();
        if (!isUndefined(body) && body != EMPTY_STRING) {
          store.setJson(body);
        } else {
          store.transaction(() =>
            store.setTables(initialTables).setValues(initialValues),
          );
        }
        loadSave = 0;
      }
      return persister;
    },
    startAutoLoad: async (initialTables, initialValues) => {
      persister.stopAutoLoad();
      await persister.load(initialTables, initialValues);
      startListeningToPersisted(persister.load);
      return persister;
    },
    stopAutoLoad: () => {
      stopListeningToPersisted();
      return persister;
    },
    save: async () => {
      /* istanbul ignore else */
      if (loadSave != 1) {
        loadSave = 2;
        {
          saves++;
        }
        await setPersisted(store.getJson());
        loadSave = 0;
      }
      return persister;
    },
    startAutoSave: async () => {
      await persister.stopAutoSave().save();
      tablesListenerId = store.addTablesListener(persister.save);
      valuesListenerId = store.addValuesListener(persister.save);
      return persister;
    },
    stopAutoSave: () => {
      ifNotUndefined(tablesListenerId, store.delListener);
      ifNotUndefined(valuesListenerId, store.delListener);
      return persister;
    },
    getStore: () => store,
    destroy: () => persister.stopAutoLoad().stopAutoSave(),
    getStats: () => ({loads, saves}),
  };
  return objFreeze(persister);
};

const STORAGE = 'storage';
const WINDOW = globalThis.window;
const getStoragePersister = (store, storageName, storage) => {
  let listener;
  const getPersisted = async () => storage.getItem(storageName);
  const setPersisted = async (json) => storage.setItem(storageName, json);
  const startListeningToPersisted = (didChange) => {
    listener = (event) => {
      if (event.storageArea === storage && event.key === storageName) {
        didChange();
      }
    };
    WINDOW.addEventListener(STORAGE, listener);
  };
  const stopListeningToPersisted = () => {
    WINDOW.removeEventListener(STORAGE, listener);
    listener = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};
const createLocalPersister = (store, storageName) =>
  getStoragePersister(store, storageName, localStorage);
const createSessionPersister = (store, storageName) =>
  getStoragePersister(store, storageName, sessionStorage);

const createFilePersister = (store, filePath) => {
  let watcher;
  const getPersisted = async () => {
    try {
      return await promises.readFile(filePath, UTF8);
    } catch {}
  };
  const setPersisted = async (json) => {
    try {
      await promises.writeFile(filePath, json, UTF8);
    } catch {}
  };
  const startListeningToPersisted = (didChange) => {
    watcher = watch(filePath, didChange);
  };
  const stopListeningToPersisted = () => {
    watcher?.close();
    watcher = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};

const getETag = (response) => response.headers.get('ETag');
const createRemotePersister = (
  store,
  loadUrl,
  saveUrl,
  autoLoadIntervalSeconds,
) => {
  let interval;
  let lastEtag;
  const getPersisted = async () => {
    const response = await fetch(loadUrl);
    lastEtag = getETag(response);
    return response.text();
  };
  const setPersisted = async (json) =>
    await fetch(saveUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: json,
    });
  const startListeningToPersisted = (didChange) => {
    interval = setInterval(async () => {
      const response = await fetch(loadUrl, {method: 'HEAD'});
      const currentEtag = getETag(response);
      if (
        !isUndefined(lastEtag) &&
        !isUndefined(currentEtag) &&
        currentEtag != lastEtag
      ) {
        lastEtag = currentEtag;
        didChange();
      }
    }, autoLoadIntervalSeconds * 1e3);
  };
  const stopListeningToPersisted = () => {
    ifNotUndefined(interval, clearInterval);
    interval = void 0;
  };
  return createCustomPersister(
    store,
    getPersisted,
    setPersisted,
    startListeningToPersisted,
    stopListeningToPersisted,
  );
};

const createQueries = getCreateFunction((store) => {
  const createStore = store.createStore;
  const [
    getStore,
    getQueryIds,
    forEachQuery,
    hasQuery,
    getTableId,
    ,
    ,
    setDefinition,
    ,
    delDefinition,
    destroy,
    addStoreListeners,
    delStoreListeners,
  ] = getDefinableFunctions(store, () => true, getUndefined);
  const preStore = createStore();
  const resultStore = createStore();
  const preStoreListenerIds = mapNew();
  const addPreStoreListener = (preStore2, queryId, ...listenerIds) =>
    arrayForEach(listenerIds, (listenerId) =>
      setAdd(
        mapEnsure(
          mapEnsure(preStoreListenerIds, queryId, mapNew),
          preStore2,
          setNew,
        ),
        listenerId,
      ),
    );
  const resetPreStores = (queryId) => {
    ifNotUndefined(
      mapGet(preStoreListenerIds, queryId),
      (queryPreStoreListenerIds) => {
        mapForEach(queryPreStoreListenerIds, (preStore2, listenerIds) =>
          collForEach(listenerIds, (listenerId) =>
            preStore2.delListener(listenerId),
          ),
        );
        collClear(queryPreStoreListenerIds);
      },
    );
    arrayForEach([resultStore, preStore], (store2) => store2.delTable(queryId));
  };
  const synchronizeTransactions = (queryId, fromStore, toStore) =>
    addPreStoreListener(
      fromStore,
      queryId,
      fromStore.addWillFinishTransactionListener(toStore.startTransaction),
      fromStore.addDidFinishTransactionListener(() =>
        toStore.finishTransaction(),
      ),
    );
  const setQueryDefinition = (queryId, tableId, build) => {
    setDefinition(queryId, tableId);
    resetPreStores(queryId);
    const selectEntries = [];
    const joinEntries = [[null, [tableId, null, null, [], mapNew()]]];
    const wheres = [];
    const groupEntries = [];
    const havings = [];
    const select = (arg1, arg2) => {
      const selectEntry = isFunction(arg1)
        ? [arrayLength(selectEntries) + EMPTY_STRING, arg1]
        : [
            isUndefined(arg2) ? arg1 : arg2,
            (getTableCell) => getTableCell(arg1, arg2),
          ];
      arrayPush(selectEntries, selectEntry);
      return {as: (selectedCellId) => (selectEntry[0] = selectedCellId)};
    };
    const join = (joinedTableId, arg1, arg2) => {
      const fromIntermediateJoinedTableId =
        isUndefined(arg2) || isFunction(arg1) ? null : arg1;
      const onArg = isUndefined(fromIntermediateJoinedTableId) ? arg1 : arg2;
      const joinEntry = [
        joinedTableId,
        [
          joinedTableId,
          fromIntermediateJoinedTableId,
          isFunction(onArg) ? onArg : (getCell) => getCell(onArg),
          [],
          mapNew(),
        ],
      ];
      arrayPush(joinEntries, joinEntry);
      return {as: (joinedTableId2) => (joinEntry[0] = joinedTableId2)};
    };
    const where = (arg1, arg2, arg3) =>
      arrayPush(
        wheres,
        isFunction(arg1)
          ? arg1
          : isUndefined(arg3)
          ? (getTableCell) => getTableCell(arg1) === arg2
          : (getTableCell) => getTableCell(arg1, arg2) === arg3,
      );
    const group = (
      selectedCellId,
      aggregate,
      aggregateAdd,
      aggregateRemove,
      aggregateReplace,
    ) => {
      const groupEntry = [
        selectedCellId,
        [
          selectedCellId,
          isFunction(aggregate)
            ? [aggregate, aggregateAdd, aggregateRemove, aggregateReplace]
            : mapGet(numericAggregators, aggregate) ?? [
                (_cells, length) => length,
              ],
        ],
      ];
      arrayPush(groupEntries, groupEntry);
      return {as: (groupedCellId) => (groupEntry[0] = groupedCellId)};
    };
    const having = (arg1, arg2) =>
      arrayPush(
        havings,
        isFunction(arg1)
          ? arg1
          : (getSelectedOrGroupedCell) =>
              getSelectedOrGroupedCell(arg1) === arg2,
      );
    build({select, join, where, group, having});
    const selects = mapNew(selectEntries);
    if (collIsEmpty(selects)) {
      return queries;
    }
    const joins = mapNew(joinEntries);
    mapForEach(joins, (asTableId, [, fromAsTableId]) =>
      ifNotUndefined(mapGet(joins, fromAsTableId), ({3: toAsTableIds}) =>
        isUndefined(asTableId) ? 0 : arrayPush(toAsTableIds, asTableId),
      ),
    );
    const groups = mapNew(groupEntries);
    let selectJoinWhereStore = preStore;
    if (collIsEmpty(groups) && arrayIsEmpty(havings)) {
      selectJoinWhereStore = resultStore;
    } else {
      synchronizeTransactions(queryId, selectJoinWhereStore, resultStore);
      const groupedSelectedCellIds = mapNew();
      mapForEach(groups, (groupedCellId, [selectedCellId, aggregators]) =>
        setAdd(mapEnsure(groupedSelectedCellIds, selectedCellId, setNew), [
          groupedCellId,
          aggregators,
        ]),
      );
      const groupBySelectedCellIds = setNew();
      mapForEach(selects, (selectedCellId) =>
        collHas(groupedSelectedCellIds, selectedCellId)
          ? 0
          : setAdd(groupBySelectedCellIds, selectedCellId),
      );
      const tree = mapNew();
      const writeGroupRow = (
        leaf,
        changedGroupedSelectedCells,
        selectedRowId,
        forceRemove,
      ) =>
        ifNotUndefined(
          leaf,
          ([selectedCells, selectedRowIds, groupRowId, groupRow]) => {
            mapForEach(
              changedGroupedSelectedCells,
              (selectedCellId, [newCell]) => {
                const selectedCell = mapEnsure(
                  selectedCells,
                  selectedCellId,
                  mapNew,
                );
                const oldLeafCell = mapGet(selectedCell, selectedRowId);
                const newLeafCell = forceRemove ? void 0 : newCell;
                if (oldLeafCell !== newLeafCell) {
                  const oldNewSet = setNew([[oldLeafCell, newLeafCell]]);
                  const oldLength = collSize(selectedCell);
                  mapSet(selectedCell, selectedRowId, newLeafCell);
                  collForEach(
                    mapGet(groupedSelectedCellIds, selectedCellId),
                    ([groupedCellId, aggregators]) => {
                      const aggregateValue = getAggregateValue(
                        groupRow[groupedCellId],
                        oldLength,
                        selectedCell,
                        oldNewSet,
                        aggregators,
                      );
                      groupRow[groupedCellId] = isUndefined(
                        getCellOrValueType(aggregateValue),
                      )
                        ? null
                        : aggregateValue;
                    },
                  );
                }
              },
            );
            if (
              collIsEmpty(selectedRowIds) ||
              !arrayEvery(havings, (having2) =>
                having2((cellId) => groupRow[cellId]),
              )
            ) {
              resultStore.delRow(queryId, groupRowId);
            } else if (isUndefined(groupRowId)) {
              leaf[2] = resultStore.addRow(queryId, groupRow);
            } else {
              resultStore.setRow(queryId, groupRowId, groupRow);
            }
          },
        );
      addPreStoreListener(
        selectJoinWhereStore,
        queryId,
        selectJoinWhereStore.addRowListener(
          queryId,
          null,
          (_store, _tableId, selectedRowId, getCellChange) => {
            const oldPath = [];
            const newPath = [];
            const changedGroupedSelectedCells = mapNew();
            const rowExists = selectJoinWhereStore.hasRow(
              queryId,
              selectedRowId,
            );
            let changedLeaf = !rowExists;
            collForEach(groupBySelectedCellIds, (selectedCellId) => {
              const [changed, oldCell, newCell] = getCellChange(
                queryId,
                selectedRowId,
                selectedCellId,
              );
              arrayPush(oldPath, oldCell);
              arrayPush(newPath, newCell);
              changedLeaf ||= changed;
            });
            mapForEach(groupedSelectedCellIds, (selectedCellId) => {
              const [changed, , newCell] = getCellChange(
                queryId,
                selectedRowId,
                selectedCellId,
              );
              if (changedLeaf || changed) {
                mapSet(changedGroupedSelectedCells, selectedCellId, [newCell]);
              }
            });
            if (changedLeaf) {
              writeGroupRow(
                visitTree(tree, oldPath, void 0, ([, selectedRowIds]) => {
                  collDel(selectedRowIds, selectedRowId);
                  return collIsEmpty(selectedRowIds);
                }),
                changedGroupedSelectedCells,
                selectedRowId,
                1,
              );
            }
            if (rowExists) {
              writeGroupRow(
                visitTree(
                  tree,
                  newPath,
                  () => {
                    const groupRow = {};
                    collForEach(
                      groupBySelectedCellIds,
                      (selectedCellId) =>
                        (groupRow[selectedCellId] =
                          selectJoinWhereStore.getCell(
                            queryId,
                            selectedRowId,
                            selectedCellId,
                          )),
                    );
                    return [mapNew(), setNew(), void 0, groupRow];
                  },
                  ([, selectedRowIds]) => {
                    setAdd(selectedRowIds, selectedRowId);
                  },
                ),
                changedGroupedSelectedCells,
                selectedRowId,
              );
            }
          },
        ),
      );
    }
    synchronizeTransactions(queryId, store, selectJoinWhereStore);
    const writeSelectRow = (rootRowId) => {
      const getTableCell = (arg1, arg2) =>
        store.getCell(
          ...(isUndefined(arg2)
            ? [tableId, rootRowId, arg1]
            : arg1 === tableId
            ? [tableId, rootRowId, arg2]
            : [
                mapGet(joins, arg1)?.[0],
                mapGet(mapGet(joins, arg1)?.[4], rootRowId)?.[0],
                arg2,
              ]),
        );
      selectJoinWhereStore.transaction(() =>
        arrayEvery(wheres, (where2) => where2(getTableCell))
          ? mapForEach(selects, (asCellId, tableCellGetter) =>
              setOrDelCell(
                selectJoinWhereStore,
                queryId,
                rootRowId,
                asCellId,
                tableCellGetter(getTableCell, rootRowId),
              ),
            )
          : selectJoinWhereStore.delRow(queryId, rootRowId),
      );
    };
    const listenToTable = (rootRowId, tableId2, rowId, joinedTableIds2) => {
      const getCell = (cellId) => store.getCell(tableId2, rowId, cellId);
      arrayForEach(joinedTableIds2, (remoteAsTableId) => {
        const [realJoinedTableId, , on, nextJoinedTableIds, remoteIdPair] =
          mapGet(joins, remoteAsTableId);
        const remoteRowId = on?.(getCell, rootRowId);
        const [previousRemoteRowId, previousRemoteListenerId] =
          mapGet(remoteIdPair, rootRowId) ?? [];
        if (remoteRowId != previousRemoteRowId) {
          if (!isUndefined(previousRemoteListenerId)) {
            delStoreListeners(queryId, previousRemoteListenerId);
          }
          mapSet(
            remoteIdPair,
            rootRowId,
            isUndefined(remoteRowId)
              ? null
              : [
                  remoteRowId,
                  ...addStoreListeners(
                    queryId,
                    1,
                    store.addRowListener(realJoinedTableId, remoteRowId, () =>
                      listenToTable(
                        rootRowId,
                        realJoinedTableId,
                        remoteRowId,
                        nextJoinedTableIds,
                      ),
                    ),
                  ),
                ],
          );
        }
      });
      writeSelectRow(rootRowId);
    };
    const {3: joinedTableIds} = mapGet(joins, null);
    selectJoinWhereStore.transaction(() =>
      addStoreListeners(
        queryId,
        1,
        store.addRowListener(tableId, null, (_store, _tableId, rootRowId) => {
          if (store.hasRow(tableId, rootRowId)) {
            listenToTable(rootRowId, tableId, rootRowId, joinedTableIds);
          } else {
            selectJoinWhereStore.delRow(queryId, rootRowId);
            collForEach(joins, ({4: idsByRootRowId}) =>
              ifNotUndefined(
                mapGet(idsByRootRowId, rootRowId),
                ([, listenerId]) => {
                  delStoreListeners(queryId, listenerId);
                  mapSet(idsByRootRowId, rootRowId);
                },
              ),
            );
          }
        }),
      ),
    );
    return queries;
  };
  const delQueryDefinition = (queryId) => {
    resetPreStores(queryId);
    delDefinition(queryId);
    return queries;
  };
  const delListener = (listenerId) => {
    resultStore.delListener(listenerId);
    return queries;
  };
  const getListenerStats = () => {
    const {
      tables: _1,
      tableIds: _2,
      transaction: _3,
      ...stats
    } = resultStore.getListenerStats();
    return stats;
  };
  const queries = {
    setQueryDefinition,
    delQueryDefinition,
    getStore,
    getQueryIds,
    forEachQuery,
    hasQuery,
    getTableId,
    delListener,
    destroy,
    getListenerStats,
  };
  objMap(
    {
      [TABLE]: [1, 1],
      [ROW_IDS]: [0, 1],
      [SORTED_ROW_IDS]: [0, 5],
      [ROW]: [1, 2],
      [CELL_IDS]: [0, 2],
      [CELL]: [1, 3],
    },
    ([hasAndForEach, argumentCount], gettable) => {
      arrayForEach(
        hasAndForEach ? [GET, 'has', 'forEach'] : [GET],
        (prefix) =>
          (queries[prefix + RESULT + gettable] = (...args) =>
            resultStore[prefix + gettable](...args)),
      );
      queries[ADD + RESULT + gettable + LISTENER] = (...args) =>
        resultStore[ADD + gettable + LISTENER](
          ...arraySlice(args, 0, argumentCount),
          (_store, ...listenerArgs) =>
            args[argumentCount](queries, ...listenerArgs),
        );
    },
  );
  return objFreeze(queries);
});

const createRelationships = getCreateFunction((store) => {
  const remoteTableIds = mapNew();
  const remoteRowIdListeners = mapNew();
  const localRowIdsListeners = mapNew();
  const linkedRowIdsListeners = mapNew();
  const [
    getStore,
    getRelationshipIds,
    forEachRelationshipImpl,
    hasRelationship,
    getLocalTableId,
    getRelationship,
    ,
    ,
    setDefinitionAndListen,
    delDefinition,
    destroy,
  ] = getDefinableFunctions(
    store,
    () => [mapNew(), mapNew(), mapNew(), mapNew()],
    (value) => (isUndefined(value) ? void 0 : value + EMPTY_STRING),
  );
  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(
    () => relationships,
  );
  const getLinkedRowIdsCache = (relationshipId, firstRowId, skipCache) =>
    ifNotUndefined(
      getRelationship(relationshipId),
      ([remoteRows, , linkedRowsCache]) => {
        if (!collHas(linkedRowsCache, firstRowId)) {
          const linkedRows = setNew();
          if (
            getLocalTableId(relationshipId) != getRemoteTableId(relationshipId)
          ) {
            setAdd(linkedRows, firstRowId);
          } else {
            let rowId = firstRowId;
            while (!isUndefined(rowId) && !collHas(linkedRows, rowId)) {
              setAdd(linkedRows, rowId);
              rowId = mapGet(remoteRows, rowId);
            }
          }
          if (skipCache) {
            return linkedRows;
          }
          mapSet(linkedRowsCache, firstRowId, linkedRows);
        }
        return mapGet(linkedRowsCache, firstRowId);
      },
    );
  const delLinkedRowIdsCache = (relationshipId, firstRowId) =>
    ifNotUndefined(getRelationship(relationshipId), ([, , linkedRowsCache]) =>
      mapSet(linkedRowsCache, firstRowId),
    );
  const setRelationshipDefinition = (
    relationshipId,
    localTableId,
    remoteTableId,
    getRemoteRowId2,
  ) => {
    mapSet(remoteTableIds, relationshipId, remoteTableId);
    setDefinitionAndListen(
      relationshipId,
      localTableId,
      (change, changedRemoteRowIds) => {
        const changedLocalRows = setNew();
        const changedRemoteRows = setNew();
        const changedLinkedRows = setNew();
        const [localRows, remoteRows] = getRelationship(relationshipId);
        collForEach(
          changedRemoteRowIds,
          ([oldRemoteRowId, newRemoteRowId], localRowId) => {
            if (!isUndefined(oldRemoteRowId)) {
              setAdd(changedRemoteRows, oldRemoteRowId);
              ifNotUndefined(
                mapGet(remoteRows, oldRemoteRowId),
                (oldRemoteRow) => {
                  collDel(oldRemoteRow, localRowId);
                  if (collIsEmpty(oldRemoteRow)) {
                    mapSet(remoteRows, oldRemoteRowId);
                  }
                },
              );
            }
            if (!isUndefined(newRemoteRowId)) {
              setAdd(changedRemoteRows, newRemoteRowId);
              if (!collHas(remoteRows, newRemoteRowId)) {
                mapSet(remoteRows, newRemoteRowId, setNew());
              }
              setAdd(mapGet(remoteRows, newRemoteRowId), localRowId);
            }
            setAdd(changedLocalRows, localRowId);
            mapSet(localRows, localRowId, newRemoteRowId);
            mapForEach(
              mapGet(linkedRowIdsListeners, relationshipId),
              (firstRowId) => {
                if (
                  collHas(
                    getLinkedRowIdsCache(relationshipId, firstRowId),
                    localRowId,
                  )
                ) {
                  setAdd(changedLinkedRows, firstRowId);
                }
              },
            );
          },
        );
        change();
        collForEach(changedLocalRows, (localRowId) =>
          callListeners(remoteRowIdListeners, [relationshipId, localRowId]),
        );
        collForEach(changedRemoteRows, (remoteRowId) =>
          callListeners(localRowIdsListeners, [relationshipId, remoteRowId]),
        );
        collForEach(changedLinkedRows, (firstRowId) => {
          delLinkedRowIdsCache(relationshipId, firstRowId);
          callListeners(linkedRowIdsListeners, [relationshipId, firstRowId]);
        });
      },
      getRowCellFunction(getRemoteRowId2),
    );
    return relationships;
  };
  const forEachRelationship = (relationshipCallback) =>
    forEachRelationshipImpl((relationshipId) =>
      relationshipCallback(relationshipId, (rowCallback) =>
        store.forEachRow(getLocalTableId(relationshipId), rowCallback),
      ),
    );
  const delRelationshipDefinition = (relationshipId) => {
    mapSet(remoteTableIds, relationshipId);
    delDefinition(relationshipId);
    return relationships;
  };
  const getRemoteTableId = (relationshipId) =>
    mapGet(remoteTableIds, relationshipId);
  const getRemoteRowId = (relationshipId, localRowId) =>
    mapGet(getRelationship(relationshipId)?.[0], localRowId);
  const getLocalRowIds = (relationshipId, remoteRowId) =>
    collValues(mapGet(getRelationship(relationshipId)?.[1], remoteRowId));
  const getLinkedRowIds = (relationshipId, firstRowId) =>
    isUndefined(getRelationship(relationshipId))
      ? [firstRowId]
      : collValues(getLinkedRowIdsCache(relationshipId, firstRowId, true));
  const addRemoteRowIdListener = (relationshipId, localRowId, listener) =>
    addListener(listener, remoteRowIdListeners, [relationshipId, localRowId]);
  const addLocalRowIdsListener = (relationshipId, remoteRowId, listener) =>
    addListener(listener, localRowIdsListeners, [relationshipId, remoteRowId]);
  const addLinkedRowIdsListener = (relationshipId, firstRowId, listener) => {
    getLinkedRowIdsCache(relationshipId, firstRowId);
    return addListener(listener, linkedRowIdsListeners, [
      relationshipId,
      firstRowId,
    ]);
  };
  const delListener = (listenerId) => {
    delLinkedRowIdsCache(...delListenerImpl(listenerId));
    return relationships;
  };
  const getListenerStats = () => ({
    remoteRowId: collSize3(remoteRowIdListeners),
    localRowIds: collSize3(localRowIdsListeners),
    linkedRowIds: collSize3(linkedRowIdsListeners),
  });
  const relationships = {
    setRelationshipDefinition,
    delRelationshipDefinition,
    getStore,
    getRelationshipIds,
    forEachRelationship,
    hasRelationship,
    getLocalTableId,
    getRemoteTableId,
    getRemoteRowId,
    getLocalRowIds,
    getLinkedRowIds,
    addRemoteRowIdListener,
    addLocalRowIdsListener,
    addLinkedRowIdsListener,
    delListener,
    destroy,
    getListenerStats,
  };
  return objFreeze(relationships);
});

const pairNew = (value) => [value, value];
const pairCollSize2 = (pair, func = collSize2) => func(pair[0]) + func(pair[1]);
const pairNewMap = () => [mapNew(), mapNew()];

const transformMap = (map, toBeLikeObject, setId, delId = mapSet) => {
  const idsToDelete = arrayFilter(
    mapKeys(map),
    (id2) => !objHas(toBeLikeObject, id2),
  );
  arrayForEach(objIds(toBeLikeObject), (id2) =>
    setId(map, id2, toBeLikeObject[id2]),
  );
  arrayForEach(idsToDelete, (id2) => delId(map, id2));
  return map;
};
const validate = (obj, validateChild, onInvalidObj) => {
  if (isUndefined(obj) || !isObject(obj) || objIsEmpty(obj) || objFrozen(obj)) {
    onInvalidObj?.();
    return false;
  }
  objMap(obj, (child, id2) => {
    if (!validateChild(child, id2)) {
      objDel(obj, id2);
    }
  });
  return !objIsEmpty(obj);
};
const idsChanged = (changedIds, id2, added) =>
  mapSet(changedIds, id2, mapGet(changedIds, id2) == -added ? void 0 : added);
const createStore = () => {
  let hasTablesSchema;
  let hasValuesSchema;
  let cellsTouched;
  let valuesTouched;
  let transactions = 0;
  const changedTableIds = mapNew();
  const changedRowIds = mapNew();
  const changedCellIds = mapNew();
  const changedCells = mapNew();
  const changedValueIds = mapNew();
  const changedValues = mapNew();
  const invalidCells = mapNew();
  const invalidValues = mapNew();
  const tablesSchemaMap = mapNew();
  const tablesSchemaRowCache = mapNew();
  const valuesSchemaMap = mapNew();
  const valuesDefaulted = mapNew();
  const valuesNonDefaulted = setNew();
  const tablePoolFunctions = mapNew();
  const tablesMap = mapNew();
  const valuesMap = mapNew();
  const tablesListeners = pairNewMap();
  const tableIdsListeners = pairNewMap();
  const tableListeners = pairNewMap();
  const rowIdsListeners = pairNewMap();
  const sortedRowIdsListeners = pairNewMap();
  const rowListeners = pairNewMap();
  const cellIdsListeners = pairNewMap();
  const cellListeners = pairNewMap();
  const invalidCellListeners = pairNewMap();
  const invalidValueListeners = pairNewMap();
  const valuesListeners = pairNewMap();
  const valueIdsListeners = pairNewMap();
  const valueListeners = pairNewMap();
  const finishTransactionListeners = pairNewMap();
  const [addListener, callListeners, delListenerImpl, callListenerImpl] =
    getListenerFunctions(() => store);
  const validateTablesSchema = (tableSchema) =>
    validate(tableSchema, (tableSchema2) =>
      validate(tableSchema2, validateCellOrValueSchema),
    );
  const validateValuesSchema = (valuesSchema) =>
    validate(valuesSchema, validateCellOrValueSchema);
  const validateCellOrValueSchema = (schema) => {
    if (!validate(schema, (_child, id2) => arrayHas([TYPE, DEFAULT], id2))) {
      return false;
    }
    const type = schema[TYPE];
    if (!isTypeStringOrBoolean(type) && type != NUMBER) {
      return false;
    }
    if (getCellOrValueType(schema[DEFAULT]) != type) {
      objDel(schema, DEFAULT);
    }
    return true;
  };
  const validateTables = (tables) =>
    validate(tables, validateTable, cellInvalid);
  const validateTable = (table, tableId) =>
    (!hasTablesSchema ||
      collHas(tablesSchemaMap, tableId) ||
      cellInvalid(tableId)) &&
    validate(
      table,
      (row, rowId) => validateRow(tableId, rowId, row),
      () => cellInvalid(tableId),
    );
  const validateRow = (tableId, rowId, row, skipDefaults) =>
    validate(
      skipDefaults ? row : addDefaultsToRow(row, tableId, rowId),
      (cell, cellId) =>
        ifNotUndefined(
          getValidatedCell(tableId, rowId, cellId, cell),
          (validCell) => {
            row[cellId] = validCell;
            return true;
          },
          () => false,
        ),
      () => cellInvalid(tableId, rowId),
    );
  const getValidatedCell = (tableId, rowId, cellId, cell) =>
    hasTablesSchema
      ? ifNotUndefined(
          mapGet(mapGet(tablesSchemaMap, tableId), cellId),
          (cellSchema) =>
            getCellOrValueType(cell) != cellSchema[TYPE]
              ? cellInvalid(tableId, rowId, cellId, cell, cellSchema[DEFAULT])
              : cell,
          () => cellInvalid(tableId, rowId, cellId, cell),
        )
      : isUndefined(getCellOrValueType(cell))
      ? cellInvalid(tableId, rowId, cellId, cell)
      : cell;
  const validateValues = (values, skipDefaults) =>
    validate(
      skipDefaults ? values : addDefaultsToValues(values),
      (value, valueId) =>
        ifNotUndefined(
          getValidatedValue(valueId, value),
          (validValue) => {
            values[valueId] = validValue;
            return true;
          },
          () => false,
        ),
      () => valueInvalid(),
    );
  const getValidatedValue = (valueId, value) =>
    hasValuesSchema
      ? ifNotUndefined(
          mapGet(valuesSchemaMap, valueId),
          (valueSchema) =>
            getCellOrValueType(value) != valueSchema[TYPE]
              ? valueInvalid(valueId, value, valueSchema[DEFAULT])
              : value,
          () => valueInvalid(valueId, value),
        )
      : isUndefined(getCellOrValueType(value))
      ? valueInvalid(valueId, value)
      : value;
  const addDefaultsToRow = (row, tableId, rowId) => {
    ifNotUndefined(
      mapGet(tablesSchemaRowCache, tableId),
      ([rowDefaulted, rowNonDefaulted]) => {
        collForEach(rowDefaulted, (cell, cellId) => {
          if (!objHas(row, cellId)) {
            row[cellId] = cell;
          }
        });
        collForEach(rowNonDefaulted, (cellId) => {
          if (!objHas(row, cellId)) {
            cellInvalid(tableId, rowId, cellId);
          }
        });
      },
    );
    return row;
  };
  const addDefaultsToValues = (values) => {
    if (hasValuesSchema) {
      collForEach(valuesDefaulted, (value, valueId) => {
        if (!objHas(values, valueId)) {
          values[valueId] = value;
        }
      });
      collForEach(valuesNonDefaulted, (valueId) => {
        if (!objHas(values, valueId)) {
          valueInvalid(valueId);
        }
      });
    }
    return values;
  };
  const setValidTablesSchema = (tablesSchema) =>
    transformMap(
      tablesSchemaMap,
      tablesSchema,
      (_tablesSchema, tableId, tableSchema) => {
        const rowDefaulted = mapNew();
        const rowNonDefaulted = setNew();
        transformMap(
          mapEnsure(tablesSchemaMap, tableId, mapNew),
          tableSchema,
          (tableSchemaMap, cellId, cellSchema) => {
            mapSet(tableSchemaMap, cellId, cellSchema);
            ifNotUndefined(
              cellSchema[DEFAULT],
              (def) => mapSet(rowDefaulted, cellId, def),
              () => setAdd(rowNonDefaulted, cellId),
            );
          },
        );
        mapSet(tablesSchemaRowCache, tableId, [rowDefaulted, rowNonDefaulted]);
      },
      (_tablesSchema, tableId) => {
        mapSet(tablesSchemaMap, tableId);
        mapSet(tablesSchemaRowCache, tableId);
      },
    );
  const setValidValuesSchema = (valuesSchema) =>
    transformMap(
      valuesSchemaMap,
      valuesSchema,
      (_valuesSchema, valueId, valueSchema) => {
        mapSet(valuesSchemaMap, valueId, valueSchema);
        ifNotUndefined(
          valueSchema[DEFAULT],
          (def) => mapSet(valuesDefaulted, valueId, def),
          () => setAdd(valuesNonDefaulted, valueId),
        );
      },
      (_valuesSchema, valueId) => {
        mapSet(valuesSchemaMap, valueId);
        mapSet(valuesDefaulted, valueId);
        collDel(valuesNonDefaulted, valueId);
      },
    );
  const setOrDelTables = (tables) =>
    objIsEmpty(tables) ? delTables() : setTables(tables);
  const setValidTables = (tables) =>
    transformMap(
      tablesMap,
      tables,
      (_tables, tableId, table) => setValidTable(tableId, table),
      (_tables, tableId) => delValidTable(tableId),
    );
  const setValidTable = (tableId, table) =>
    transformMap(
      mapEnsure(tablesMap, tableId, () => {
        tableIdsChanged(tableId, 1);
        return mapNew();
      }),
      table,
      (tableMap, rowId, row) => setValidRow(tableId, tableMap, rowId, row),
      (tableMap, rowId) => delValidRow(tableId, tableMap, rowId),
    );
  const setValidRow = (tableId, tableMap, rowId, row, forceDel) =>
    transformMap(
      mapEnsure(tableMap, rowId, () => {
        rowIdsChanged(tableId, rowId, 1);
        return mapNew();
      }),
      row,
      (rowMap, cellId, cell) =>
        setValidCell(tableId, rowId, rowMap, cellId, cell),
      (rowMap, cellId) =>
        delValidCell(tableId, tableMap, rowId, rowMap, cellId, forceDel),
    );
  const setValidCell = (tableId, rowId, rowMap, cellId, cell) => {
    if (!collHas(rowMap, cellId)) {
      cellIdsChanged(tableId, rowId, cellId, 1);
    }
    const oldCell = mapGet(rowMap, cellId);
    if (cell !== oldCell) {
      cellChanged(tableId, rowId, cellId, oldCell, cell);
      mapSet(rowMap, cellId, cell);
    }
  };
  const setCellIntoDefaultRow = (tableId, tableMap, rowId, cellId, validCell) =>
    ifNotUndefined(
      mapGet(tableMap, rowId),
      (rowMap) => setValidCell(tableId, rowId, rowMap, cellId, validCell),
      () =>
        setValidRow(
          tableId,
          tableMap,
          rowId,
          addDefaultsToRow({[cellId]: validCell}, tableId, rowId),
        ),
    );
  const setOrDelValues = (values) =>
    objIsEmpty(values) ? delValues() : setValues(values);
  const setValidValues = (values) =>
    transformMap(
      valuesMap,
      values,
      (_valuesMap, valueId, value) => setValidValue(valueId, value),
      (_valuesMap, valueId) => delValidValue(valueId),
    );
  const setValidValue = (valueId, value) => {
    if (!collHas(valuesMap, valueId)) {
      valueIdsChanged(valueId, 1);
    }
    const oldValue = mapGet(valuesMap, valueId);
    if (value !== oldValue) {
      valueChanged(valueId, oldValue, value);
      mapSet(valuesMap, valueId, value);
    }
  };
  const getNewRowId = (tableId) => {
    const [getId] = mapEnsure(tablePoolFunctions, tableId, getPoolFunctions);
    const rowId = getId();
    if (!collHas(mapGet(tablesMap, tableId), rowId)) {
      return rowId;
    }
    return getNewRowId(tableId);
  };
  const getOrCreateTable = (tableId) =>
    mapGet(tablesMap, tableId) ?? setValidTable(tableId, {});
  const delValidTable = (tableId) => setValidTable(tableId, {});
  const delValidRow = (tableId, tableMap, rowId) => {
    const [, releaseId] = mapEnsure(
      tablePoolFunctions,
      tableId,
      getPoolFunctions,
    );
    releaseId(rowId);
    setValidRow(tableId, tableMap, rowId, {}, true);
  };
  const delValidCell = (tableId, table, rowId, row, cellId, forceDel) => {
    const defaultCell = mapGet(
      mapGet(tablesSchemaRowCache, tableId)?.[0],
      cellId,
    );
    if (!isUndefined(defaultCell) && !forceDel) {
      return setValidCell(tableId, rowId, row, cellId, defaultCell);
    }
    const delCell2 = (cellId2) => {
      cellChanged(tableId, rowId, cellId2, mapGet(row, cellId2));
      cellIdsChanged(tableId, rowId, cellId2, -1);
      mapSet(row, cellId2);
    };
    isUndefined(defaultCell) ? delCell2(cellId) : mapForEach(row, delCell2);
    if (collIsEmpty(row)) {
      rowIdsChanged(tableId, rowId, -1);
      if (collIsEmpty(mapSet(table, rowId))) {
        tableIdsChanged(tableId, -1);
        mapSet(tablesMap, tableId);
        mapSet(tablePoolFunctions, tableId);
      }
    }
  };
  const delValidValue = (valueId) => {
    const defaultValue = mapGet(valuesDefaulted, valueId);
    if (!isUndefined(defaultValue)) {
      return setValidValue(valueId, defaultValue);
    }
    valueChanged(valueId, mapGet(valuesMap, valueId));
    valueIdsChanged(valueId, -1);
    mapSet(valuesMap, valueId);
  };
  const tableIdsChanged = (tableId, added) =>
    idsChanged(changedTableIds, tableId, added);
  const rowIdsChanged = (tableId, rowId, added) =>
    idsChanged(mapEnsure(changedRowIds, tableId, mapNew), rowId, added);
  const cellIdsChanged = (tableId, rowId, cellId, added) =>
    idsChanged(
      mapEnsure(mapEnsure(changedCellIds, tableId, mapNew), rowId, mapNew),
      cellId,
      added,
    );
  const cellChanged = (tableId, rowId, cellId, oldCell, newCell) =>
    (mapEnsure(
      mapEnsure(mapEnsure(changedCells, tableId, mapNew), rowId, mapNew),
      cellId,
      () => [oldCell, 0],
    )[1] = newCell);
  const valueIdsChanged = (valueId, added) =>
    idsChanged(changedValueIds, valueId, added);
  const valueChanged = (valueId, oldValue, newValue) =>
    (mapEnsure(changedValues, valueId, () => [oldValue, 0])[1] = newValue);
  const cellInvalid = (tableId, rowId, cellId, invalidCell, defaultedCell) => {
    arrayPush(
      mapEnsure(
        mapEnsure(mapEnsure(invalidCells, tableId, mapNew), rowId, mapNew),
        cellId,
        () => [],
      ),
      invalidCell,
    );
    return defaultedCell;
  };
  const valueInvalid = (valueId, invalidValue, defaultedValue) => {
    arrayPush(
      mapEnsure(invalidValues, valueId, () => []),
      invalidValue,
    );
    return defaultedValue;
  };
  const getCellChange = (tableId, rowId, cellId) =>
    ifNotUndefined(
      mapGet(mapGet(mapGet(changedCells, tableId), rowId), cellId),
      ([oldCell, newCell]) => [true, oldCell, newCell],
      () => [false, ...pairNew(getCell(tableId, rowId, cellId))],
    );
  const getValueChange = (valueId) =>
    ifNotUndefined(
      mapGet(changedValues, valueId),
      ([oldValue, newValue]) => [true, oldValue, newValue],
      () => [false, ...pairNew(getValue(valueId))],
    );
  const callInvalidCellListeners = (mutator) =>
    !collIsEmpty(invalidCells) && !collIsEmpty(invalidCellListeners[mutator])
      ? collForEach(
          mutator ? mapClone(invalidCells, mapClone2) : invalidCells,
          (rows, tableId) =>
            collForEach(rows, (cells, rowId) =>
              collForEach(cells, (invalidCell, cellId) =>
                callListeners(
                  invalidCellListeners[mutator],
                  [tableId, rowId, cellId],
                  invalidCell,
                ),
              ),
            ),
        )
      : 0;
  const callInvalidValueListeners = (mutator) =>
    !collIsEmpty(invalidValues) && !collIsEmpty(invalidValueListeners[mutator])
      ? collForEach(
          mutator ? mapClone(invalidValues) : invalidValues,
          (invalidValue, valueId) =>
            callListeners(
              invalidValueListeners[mutator],
              [valueId],
              invalidValue,
            ),
        )
      : 0;
  const callIdsListenersIfChanged = (listeners, changedIds, ids) => {
    if (!collIsEmpty(changedIds)) {
      callListeners(listeners, ids);
      return 1;
    }
  };
  const callTabularListenersForChanges = (mutator) => {
    const emptySortedRowIdListeners = collIsEmpty(
      sortedRowIdsListeners[mutator],
    );
    const emptyIdListeners =
      collIsEmpty(cellIdsListeners[mutator]) &&
      collIsEmpty(rowIdsListeners[mutator]) &&
      emptySortedRowIdListeners &&
      collIsEmpty(tableIdsListeners[mutator]);
    const emptyOtherListeners =
      collIsEmpty(cellListeners[mutator]) &&
      collIsEmpty(rowListeners[mutator]) &&
      collIsEmpty(tableListeners[mutator]) &&
      collIsEmpty(tablesListeners[mutator]);
    if (!emptyIdListeners || !emptyOtherListeners) {
      const changes = mutator
        ? [
            mapClone(changedTableIds),
            mapClone2(changedRowIds),
            mapClone(changedCellIds, mapClone2),
            mapClone(changedCells, mapClone2),
          ]
        : [changedTableIds, changedRowIds, changedCellIds, changedCells];
      if (!emptyIdListeners) {
        collForEach(changes[2], (rowCellIds, tableId) =>
          collForEach(rowCellIds, (changedIds, rowId) =>
            callIdsListenersIfChanged(cellIdsListeners[mutator], changedIds, [
              tableId,
              rowId,
            ]),
          ),
        );
        const calledSortableTableIds = setNew();
        collForEach(changes[1], (changedIds, tableId) => {
          if (
            callIdsListenersIfChanged(rowIdsListeners[mutator], changedIds, [
              tableId,
            ]) &&
            !emptySortedRowIdListeners
          ) {
            callListeners(sortedRowIdsListeners[mutator], [tableId, null]);
            setAdd(calledSortableTableIds, tableId);
          }
        });
        if (!emptySortedRowIdListeners) {
          collForEach(changes[3], (rows, tableId) => {
            if (!collHas(calledSortableTableIds, tableId)) {
              const sortableCellIds = setNew();
              collForEach(rows, (cells) =>
                collForEach(cells, ([oldCell, newCell], cellId) =>
                  newCell !== oldCell
                    ? setAdd(sortableCellIds, cellId)
                    : collDel(cells, cellId),
                ),
              );
              collForEach(sortableCellIds, (cellId) =>
                callListeners(sortedRowIdsListeners[mutator], [
                  tableId,
                  cellId,
                ]),
              );
            }
          });
        }
        callIdsListenersIfChanged(tableIdsListeners[mutator], changes[0]);
      }
      if (!emptyOtherListeners) {
        let tablesChanged;
        collForEach(changes[3], (rows, tableId) => {
          let tableChanged;
          collForEach(rows, (cells, rowId) => {
            let rowChanged;
            collForEach(cells, ([oldCell, newCell], cellId) => {
              if (newCell !== oldCell) {
                callListeners(
                  cellListeners[mutator],
                  [tableId, rowId, cellId],
                  newCell,
                  oldCell,
                  getCellChange,
                );
                tablesChanged = tableChanged = rowChanged = 1;
              }
            });
            if (rowChanged) {
              callListeners(
                rowListeners[mutator],
                [tableId, rowId],
                getCellChange,
              );
            }
          });
          if (tableChanged) {
            callListeners(tableListeners[mutator], [tableId], getCellChange);
          }
        });
        if (tablesChanged) {
          callListeners(tablesListeners[mutator], void 0, getCellChange);
        }
      }
    }
  };
  const callKeyedValuesListenersForChanges = (mutator) => {
    const emptyIdListeners = collIsEmpty(valueIdsListeners[mutator]);
    const emptyOtherListeners =
      collIsEmpty(valueListeners[mutator]) &&
      collIsEmpty(valuesListeners[mutator]);
    if (!emptyIdListeners || !emptyOtherListeners) {
      const changes = mutator
        ? [mapClone(changedValueIds), mapClone(changedValues)]
        : [changedValueIds, changedValues];
      if (!emptyIdListeners) {
        callIdsListenersIfChanged(valueIdsListeners[mutator], changes[0]);
      }
      if (!emptyOtherListeners) {
        let valuesChanged;
        collForEach(changes[1], ([oldValue, newValue], valueId) => {
          if (newValue !== oldValue) {
            callListeners(
              valueListeners[mutator],
              [valueId],
              newValue,
              oldValue,
              getValueChange,
            );
            valuesChanged = 1;
          }
        });
        if (valuesChanged) {
          callListeners(valuesListeners[mutator], void 0, getValueChange);
        }
      }
    }
  };
  const fluentTransaction = (actions, ...args) => {
    transaction(() => actions(...arrayMap(args, id)));
    return store;
  };
  const getTables = () =>
    mapToObj(tablesMap, (table) => mapToObj(table, mapToObj));
  const getTableIds = () => mapKeys(tablesMap);
  const getTable = (tableId) =>
    mapToObj(mapGet(tablesMap, id(tableId)), mapToObj);
  const getRowIds = (tableId) => mapKeys(mapGet(tablesMap, id(tableId)));
  const getSortedRowIds = (tableId, cellId, descending, offset = 0, limit) =>
    arrayMap(
      arraySlice(
        arraySort(
          mapMap(mapGet(tablesMap, id(tableId)), (row, rowId) => [
            isUndefined(cellId) ? rowId : mapGet(row, id(cellId)),
            rowId,
          ]),
          ([cell1], [cell2]) =>
            defaultSorter(cell1, cell2) * (descending ? -1 : 1),
        ),
        offset,
        isUndefined(limit) ? limit : offset + limit,
      ),
      ([, rowId]) => rowId,
    );
  const getRow = (tableId, rowId) =>
    mapToObj(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
  const getCellIds = (tableId, rowId) =>
    mapKeys(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
  const getCell = (tableId, rowId, cellId) =>
    mapGet(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
  const getValues = () => mapToObj(valuesMap);
  const getValueIds = () => mapKeys(valuesMap);
  const getValue = (valueId) => mapGet(valuesMap, id(valueId));
  const hasTables = () => !collIsEmpty(tablesMap);
  const hasTable = (tableId) => collHas(tablesMap, id(tableId));
  const hasRow = (tableId, rowId) =>
    collHas(mapGet(tablesMap, id(tableId)), id(rowId));
  const hasCell = (tableId, rowId, cellId) =>
    collHas(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
  const hasValues = () => !collIsEmpty(valuesMap);
  const hasValue = (valueId) => collHas(valuesMap, id(valueId));
  const getTablesJson = () => jsonString(tablesMap);
  const getValuesJson = () => jsonString(valuesMap);
  const getJson = () => jsonString([tablesMap, valuesMap]);
  const getTablesSchemaJson = () => jsonString(tablesSchemaMap);
  const getValuesSchemaJson = () => jsonString(valuesSchemaMap);
  const getSchemaJson = () => jsonString([tablesSchemaMap, valuesSchemaMap]);
  const setTables = (tables) =>
    fluentTransaction(() =>
      validateTables(tables) ? setValidTables(tables) : 0,
    );
  const setTable = (tableId, table) =>
    fluentTransaction(
      (tableId2) =>
        validateTable(table, tableId2) ? setValidTable(tableId2, table) : 0,
      tableId,
    );
  const setRow = (tableId, rowId, row) =>
    fluentTransaction(
      (tableId2, rowId2) =>
        validateRow(tableId2, rowId2, row)
          ? setValidRow(tableId2, getOrCreateTable(tableId2), rowId2, row)
          : 0,
      tableId,
      rowId,
    );
  const addRow = (tableId, row) =>
    transaction(() => {
      let rowId = void 0;
      if (validateRow(tableId, rowId, row)) {
        tableId = id(tableId);
        setValidRow(
          tableId,
          getOrCreateTable(tableId),
          (rowId = getNewRowId(tableId)),
          row,
        );
      }
      return rowId;
    });
  const setPartialRow = (tableId, rowId, partialRow) =>
    fluentTransaction(
      (tableId2, rowId2) => {
        if (validateRow(tableId2, rowId2, partialRow, 1)) {
          const table = getOrCreateTable(tableId2);
          objMap(partialRow, (cell, cellId) =>
            setCellIntoDefaultRow(tableId2, table, rowId2, cellId, cell),
          );
        }
      },
      tableId,
      rowId,
    );
  const setCell = (tableId, rowId, cellId, cell) =>
    fluentTransaction(
      (tableId2, rowId2, cellId2) =>
        ifNotUndefined(
          getValidatedCell(
            tableId2,
            rowId2,
            cellId2,
            isFunction(cell) ? cell(getCell(tableId2, rowId2, cellId2)) : cell,
          ),
          (validCell) =>
            setCellIntoDefaultRow(
              tableId2,
              getOrCreateTable(tableId2),
              rowId2,
              cellId2,
              validCell,
            ),
        ),
      tableId,
      rowId,
      cellId,
    );
  const setValues = (values) =>
    fluentTransaction(() =>
      validateValues(values) ? setValidValues(values) : 0,
    );
  const setPartialValues = (partialValues) =>
    fluentTransaction(() =>
      validateValues(partialValues, 1)
        ? objMap(partialValues, (value, valueId) =>
            setValidValue(valueId, value),
          )
        : 0,
    );
  const setValue = (valueId, value) =>
    fluentTransaction(
      (valueId2) =>
        ifNotUndefined(
          getValidatedValue(
            valueId2,
            isFunction(value) ? value(getValue(valueId2)) : value,
          ),
          (validValue) => setValidValue(valueId2, validValue),
        ),
      valueId,
    );
  const setTablesJson = (tablesJson) => {
    try {
      setOrDelTables(jsonParse(tablesJson));
    } catch {}
    return store;
  };
  const setValuesJson = (valuesJson) => {
    try {
      setOrDelValues(jsonParse(valuesJson));
    } catch {}
    return store;
  };
  const setJson = (tablesAndValuesJson) => {
    try {
      const [tables, values] = jsonParse(tablesAndValuesJson);
      setOrDelTables(tables);
      setOrDelValues(values);
    } catch {
      setTablesJson(tablesAndValuesJson);
    }
    return store;
  };
  const setTablesSchema = (tablesSchema) =>
    fluentTransaction(() => {
      if ((hasTablesSchema = validateTablesSchema(tablesSchema))) {
        setValidTablesSchema(tablesSchema);
        if (!collIsEmpty(tablesMap)) {
          const tables = getTables();
          delTables();
          setTables(tables);
        }
      }
    });
  const setValuesSchema = (valuesSchema) =>
    fluentTransaction(() => {
      if ((hasValuesSchema = validateValuesSchema(valuesSchema))) {
        const values = getValues();
        delValuesSchema();
        delValues();
        hasValuesSchema = true;
        setValidValuesSchema(valuesSchema);
        setValues(values);
      }
    });
  const setSchema = (tablesSchema, valuesSchema) =>
    fluentTransaction(() => {
      setTablesSchema(tablesSchema);
      setValuesSchema(valuesSchema);
    });
  const delTables = () => fluentTransaction(() => setValidTables({}));
  const delTable = (tableId) =>
    fluentTransaction(
      (tableId2) =>
        collHas(tablesMap, tableId2) ? delValidTable(tableId2) : 0,
      tableId,
    );
  const delRow = (tableId, rowId) =>
    fluentTransaction(
      (tableId2, rowId2) =>
        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>
          collHas(tableMap, rowId2)
            ? delValidRow(tableId2, tableMap, rowId2)
            : 0,
        ),
      tableId,
      rowId,
    );
  const delCell = (tableId, rowId, cellId, forceDel) =>
    fluentTransaction(
      (tableId2, rowId2, cellId2) =>
        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>
          ifNotUndefined(mapGet(tableMap, rowId2), (rowMap) =>
            collHas(rowMap, cellId2)
              ? delValidCell(
                  tableId2,
                  tableMap,
                  rowId2,
                  rowMap,
                  cellId2,
                  forceDel,
                )
              : 0,
          ),
        ),
      tableId,
      rowId,
      cellId,
    );
  const delValues = () => fluentTransaction(() => setValidValues({}));
  const delValue = (valueId) =>
    fluentTransaction(
      (valueId2) =>
        collHas(valuesMap, valueId2) ? delValidValue(valueId2) : 0,
      valueId,
    );
  const delTablesSchema = () =>
    fluentTransaction(() => {
      setValidTablesSchema({});
      hasTablesSchema = false;
    });
  const delValuesSchema = () =>
    fluentTransaction(() => {
      setValidValuesSchema({});
      hasValuesSchema = false;
    });
  const delSchema = () =>
    fluentTransaction(() => {
      delTablesSchema();
      delValuesSchema();
    });
  const transaction = (actions, doRollback) => {
    if (transactions == -1) {
      return;
    }
    startTransaction();
    const result = actions();
    finishTransaction(doRollback);
    return result;
  };
  const startTransaction = () => {
    transactions++;
    return store;
  };
  const finishTransaction = (doRollback) => {
    if (transactions > 0) {
      transactions--;
      if (transactions == 0) {
        cellsTouched = !collIsEmpty(changedCells);
        valuesTouched = !collIsEmpty(changedValues);
        transactions = 1;
        callInvalidCellListeners(1);
        if (cellsTouched) {
          callTabularListenersForChanges(1);
        }
        callInvalidValueListeners(1);
        if (valuesTouched) {
          callKeyedValuesListenersForChanges(1);
        }
        transactions = -1;
        if (
          doRollback?.(
            mapToObj(
              changedCells,
              (table) =>
                mapToObj(
                  table,
                  (row) =>
                    mapToObj(
                      row,
                      (cells) => [...cells],
                      ([oldCell, newCell]) => oldCell === newCell,
                    ),
                  objIsEmpty,
                ),
              objIsEmpty,
            ),
            mapToObj(invalidCells, (map) => mapToObj(map, mapToObj)),
            mapToObj(
              changedValues,
              (values) => [...values],
              ([oldValue, newValue]) => oldValue === newValue,
            ),
            mapToObj(invalidValues),
          )
        ) {
          transactions = 1;
          collForEach(changedCells, (table, tableId) =>
            collForEach(table, (row, rowId) =>
              collForEach(row, ([oldCell], cellId) =>
                setOrDelCell(store, tableId, rowId, cellId, oldCell),
              ),
            ),
          );
          collForEach(changedValues, ([oldValue], valueId) =>
            setOrDelValue(store, valueId, oldValue),
          );
          transactions = -1;
          cellsTouched = valuesTouched = false;
        }
        callListeners(
          finishTransactionListeners[0],
          void 0,
          cellsTouched,
          valuesTouched,
        );
        callInvalidCellListeners(0);
        if (cellsTouched) {
          callTabularListenersForChanges(0);
        }
        callInvalidValueListeners(0);
        if (valuesTouched) {
          callKeyedValuesListenersForChanges(0);
        }
        callListeners(
          finishTransactionListeners[1],
          void 0,
          cellsTouched,
          valuesTouched,
        );
        transactions = 0;
        arrayForEach(
          [
            changedTableIds,
            changedRowIds,
            changedCellIds,
            changedCells,
            invalidCells,
            changedValueIds,
            changedValues,
            invalidValues,
          ],
          collClear,
        );
      }
    }
    return store;
  };
  const forEachTable = (tableCallback) =>
    collForEach(tablesMap, (tableMap, tableId) =>
      tableCallback(tableId, (rowCallback) =>
        collForEach(tableMap, (rowMap, rowId) =>
          rowCallback(rowId, (cellCallback) =>
            mapForEach(rowMap, cellCallback),
          ),
        ),
      ),
    );
  const forEachRow = (tableId, rowCallback) =>
    collForEach(mapGet(tablesMap, id(tableId)), (rowMap, rowId) =>
      rowCallback(rowId, (cellCallback) => mapForEach(rowMap, cellCallback)),
    );
  const forEachCell = (tableId, rowId, cellCallback) =>
    mapForEach(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), cellCallback);
  const forEachValue = (valueCallback) => mapForEach(valuesMap, valueCallback);
  const addSortedRowIdsListener = (
    tableId,
    cellId,
    descending,
    offset,
    limit,
    listener,
    mutator,
  ) => {
    let sortedRowIds = getSortedRowIds(
      tableId,
      cellId,
      descending,
      offset,
      limit,
    );
    return addListener(
      () => {
        const newSortedRowIds = getSortedRowIds(
          tableId,
          cellId,
          descending,
          offset,
          limit,
        );
        if (!arrayIsEqual(newSortedRowIds, sortedRowIds)) {
          sortedRowIds = newSortedRowIds;
          listener(
            store,
            tableId,
            cellId,
            descending,
            offset,
            limit,
            sortedRowIds,
          );
        }
      },
      sortedRowIdsListeners[mutator ? 1 : 0],
      [tableId, cellId],
      [getTableIds],
    );
  };
  const addWillFinishTransactionListener = (listener) =>
    addListener(listener, finishTransactionListeners[0]);
  const addDidFinishTransactionListener = (listener) =>
    addListener(listener, finishTransactionListeners[1]);
  const callListener = (listenerId) => {
    callListenerImpl(listenerId);
    return store;
  };
  const delListener = (listenerId) => {
    delListenerImpl(listenerId);
    return store;
  };
  const getListenerStats = () => ({
    tables: pairCollSize2(tablesListeners),
    tableIds: pairCollSize2(tableIdsListeners),
    table: pairCollSize2(tableListeners),
    rowIds: pairCollSize2(rowIdsListeners),
    sortedRowIds: pairCollSize2(sortedRowIdsListeners),
    row: pairCollSize2(rowListeners, collSize3),
    cellIds: pairCollSize2(cellIdsListeners, collSize3),
    cell: pairCollSize2(cellListeners, collSize4),
    invalidCell: pairCollSize2(invalidCellListeners, collSize4),
    values: pairCollSize2(valuesListeners),
    valueIds: pairCollSize2(valueIdsListeners),
    value: pairCollSize2(valueListeners),
    invalidValue: pairCollSize2(invalidValueListeners),
    transaction: pairCollSize2(finishTransactionListeners),
  });
  const store = {
    getTables,
    getTableIds,
    getTable,
    getRowIds,
    getSortedRowIds,
    getRow,
    getCellIds,
    getCell,
    getValues,
    getValueIds,
    getValue,
    hasTables,
    hasTable,
    hasRow,
    hasCell,
    hasValues,
    hasValue,
    getTablesJson,
    getValuesJson,
    getJson,
    getTablesSchemaJson,
    getValuesSchemaJson,
    getSchemaJson,
    setTables,
    setTable,
    setRow,
    addRow,
    setPartialRow,
    setCell,
    setValues,
    setPartialValues,
    setValue,
    setTablesJson,
    setValuesJson,
    setJson,
    setTablesSchema,
    setValuesSchema,
    setSchema,
    delTables,
    delTable,
    delRow,
    delCell,
    delValues,
    delValue,
    delTablesSchema,
    delValuesSchema,
    delSchema,
    transaction,
    startTransaction,
    finishTransaction,
    forEachTable,
    forEachRow,
    forEachCell,
    forEachValue,
    addSortedRowIdsListener,
    addWillFinishTransactionListener,
    addDidFinishTransactionListener,
    callListener,
    delListener,
    getListenerStats,
    createStore,
  };
  objMap(
    {
      [TABLES]: [0, tablesListeners],
      [TABLE_IDS]: [0, tableIdsListeners],
      [TABLE]: [1, tableListeners, [getTableIds]],
      [ROW_IDS]: [1, rowIdsListeners, [getTableIds]],
      [ROW]: [2, rowListeners, [getTableIds, getRowIds]],
      [CELL_IDS]: [2, cellIdsListeners, [getTableIds, getRowIds]],
      [CELL]: [
        3,
        cellListeners,
        [getTableIds, getRowIds, getCellIds],
        (ids) => pairNew(getCell(...ids)),
      ],
      InvalidCell: [3, invalidCellListeners],
      [VALUES]: [0, valuesListeners],
      [VALUE_IDS]: [0, valueIdsListeners],
      [VALUE]: [
        1,
        valueListeners,
        [getValueIds],
        (ids) => pairNew(getValue(ids[0])),
      ],
      InvalidValue: [1, invalidValueListeners],
    },
    ([argumentCount, idSetNode, pathGetters, extraArgsGetter], listenable) => {
      store[ADD + listenable + LISTENER] = (...args) =>
        addListener(
          args[argumentCount],
          idSetNode[args[argumentCount + 1] ? 1 : 0],
          argumentCount > 0 ? arraySlice(args, 0, argumentCount) : void 0,
          pathGetters,
          extraArgsGetter,
        );
    },
  );
  return objFreeze(store);
};

export {
  createCheckpoints,
  createCustomPersister,
  createFilePersister,
  createIndexes,
  createLocalPersister,
  createMetrics,
  createQueries,
  createRelationships,
  createRemotePersister,
  createSessionPersister,
  createStore,
  defaultSorter,
};
