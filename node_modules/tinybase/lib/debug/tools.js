const getTypeOf = (thing) => typeof thing;
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const BOOLEAN = getTypeOf(true);
const NUMBER = getTypeOf(0);
const TYPE = 'type';
const DEFAULT = 'default';

const arrayEvery = (array, cb) => array.every(cb);
const arraySort = (array, sorter) => array.sort(sorter);
const arrayForEach = (array, cb) => array.forEach(cb);
const arrayMap = (array, cb) => array.map(cb);
const arrayLength = (array) => array.length;
const arrayIsEmpty = (array) => arrayLength(array) == 0;
const arrayPush = (array, ...values) => array.push(...values);
const arrayPop = (array) => array.pop();
const arrayUnshift = (array, ...values) => array.unshift(...values);
const arrayShift = (array) => array.shift();

const jsonParse = JSON.parse;
const isFiniteNumber = isFinite;
const isInstanceOf = (thing, cls) => thing instanceof cls;
const isUndefined = (thing) => thing == void 0;
const isTypeStringOrBoolean = (type) => type == STRING || type == BOOLEAN;
const isString = (thing) => getTypeOf(thing) == STRING;
const isArray = (thing) => Array.isArray(thing);

const getCellOrValueType = (cell) => {
  const type = getTypeOf(cell);
  return isTypeStringOrBoolean(type) || (type == NUMBER && isFiniteNumber(cell))
    ? type
    : void 0;
};

const collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;
const collValues = (coll) => [...(coll?.values() ?? [])];
const collForEach = (coll, cb) => coll?.forEach(cb);
const collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);

const mapNew = (entries) => new Map(entries);
const mapGet = (map, key) => map?.get(key);
const mapForEach = (map, cb) =>
  collForEach(map, (value, key) => cb(key, value));
const mapMap = (coll, cb) =>
  arrayMap([...(coll?.entries() ?? [])], ([key, value]) => cb(value, key));
const mapSet = (map, key, value) =>
  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue) => {
  if (!collHas(map, key)) {
    mapSet(map, key, getDefaultValue());
  }
  return mapGet(map, key);
};

const setNew = (entryOrEntries) =>
  new Set(
    isArray(entryOrEntries) || isUndefined(entryOrEntries)
      ? entryOrEntries
      : [entryOrEntries],
  );
const setAdd = (set, value) => set?.add(value);

const pairNew = (value) => [value, value];
const pairNewMap = () => [mapNew(), mapNew()];

const NON_ALPHA = /[^A-Za-z]+/;
const NON_ALPHANUMERIC = /[^A-Za-z0-9]+/;
const JSDOC = /^( *)\/\*\* *(.*?) *\*\/$/gm;
const substr = (str, start, end) => str.substring(start, end);
const upper = (str) => str.toUpperCase();
const lower = (str) => str.toLowerCase();
const mapUnique = (map, id, value, index = 1) => {
  const uniqueId = `${id}${index == 1 ? '' : index}`;
  if (collHas(map, uniqueId)) {
    return mapUnique(map, id, value, index + 1);
  } else {
    mapSet(map, uniqueId, value);
    return uniqueId;
  }
};
const formatJsDoc = (file) =>
  file.replace(JSDOC, (_, indent, text) => {
    const lineLength = 77 - length(indent);
    return `${indent}/**
${text.replace(
  new RegExp(`([^\\n]{1,${lineLength}})(\\s|$)`, 'g'),
  `${indent} * $1
`,
)}${indent} */`;
  });
const length = (str) => str.length;
const join = (array, sep = EMPTY_STRING) => array.join(sep);
const flat = (array) => array.flat(1e3);
const camel = (str, firstCap = 0) =>
  join(
    arrayMap(
      str.split(NON_ALPHANUMERIC),
      (word, w) =>
        (w > 0 || firstCap ? upper : lower)(substr(word, 0, 1)) +
        substr(word, 1),
    ),
  );
const snake = (str) =>
  upper(
    join(
      (str && !NON_ALPHA.test(str[0]) ? str : ' ' + str).split(
        NON_ALPHANUMERIC,
      ),
      '_',
    ),
  );
const comment = (doc) => `/** ${doc}. */`;
const getCodeFunctions = () => {
  const allImports = pairNewMap();
  const types = mapNew();
  const methods = mapNew();
  const constants = mapNew();
  const build = (...lines) => join(flat(lines), '\n');
  const addImport = (location, source, ...items) =>
    arrayForEach(items, (item) =>
      setAdd(mapEnsure(allImports[location], source, setNew), item),
    );
  const addType = (name, body, doc) => mapUnique(types, name, [body, doc]);
  const addMethod = (name, parameters, returnType, body, doc, generic = '') =>
    mapUnique(methods, name, [parameters, returnType, body, doc, generic]);
  const addFunction = (name, parameters, body) =>
    mapUnique(
      constants,
      name,
      isArray(body)
        ? [`(${parameters}) => {`, body, '}']
        : [`(${parameters}) => ${body}`],
    );
  const addConstant = (name, body) =>
    mapGet(constants, name) === body ? name : mapUnique(constants, name, body);
  const getImports = (location) => [
    ...arraySort(
      mapMap(
        allImports[location],
        (items, source) =>
          `import {${join(
            arraySort(collValues(items)),
            ', ',
          )}} from '${source}';`,
      ),
    ),
    EMPTY_STRING,
  ];
  const getTypes = () =>
    mapMap(types, ([body, doc], name) => [
      comment(doc),
      `export type ${name} = ${body};`,
      EMPTY_STRING,
    ]);
  const getMethods = (location) =>
    mapMap(methods, ([parameters, returnType, body, doc, generic], name) => {
      const lines = location
        ? [`${name}: ${generic}(${parameters}): ${returnType} => ${body},`]
        : [`${name}${generic}(${parameters}): ${returnType};`];
      if (!location) {
        arrayUnshift(lines, comment(doc));
      }
      arrayPush(lines, EMPTY_STRING);
      return lines;
    });
  const getConstants = () =>
    mapMap(constants, (body, name) => {
      body = isArray(body) ? body : [body];
      arrayPush(body, `${arrayPop(body)};`);
      return [`const ${name} = ${arrayShift(body)}`, body, EMPTY_STRING];
    });
  return [
    build,
    addImport,
    addType,
    addMethod,
    addFunction,
    addConstant,
    getImports,
    getTypes,
    getMethods,
    getConstants,
  ];
};

const object = Object;
const objIds = object.keys;
const objFreeze = object.freeze;
const isObject = (obj) =>
  isInstanceOf(obj, object) && obj.constructor == object;
const objMap = (obj, cb) =>
  arrayMap(object.entries(obj), ([id, value]) => cb(value, id));
const objIsEmpty = (obj) => isObject(obj) && arrayIsEmpty(objIds(obj));

const getCreateFunction = (getFunction) => {
  const getFunctionsByStore = /* @__PURE__ */ new WeakMap();
  return (store) => {
    if (!getFunctionsByStore.has(store)) {
      getFunctionsByStore.set(store, getFunction(store));
    }
    return getFunctionsByStore.get(store);
  };
};

const THE_STORE = 'the Store';
const A_FUNCTION_FOR = 'A function for';
const EXPORT = 'export';
const LISTENER = 'listener';
const OR_UNDEFINED = ' | undefined';
const REGISTERS_A_LISTENER = `Registers a ${LISTENER} that will be called`;
const REPRESENTS = 'Represents';
const RETURNS_VOID = ' => void';
const THE_END_OF_THE_TRANSACTION = 'the end of the transaction';
const THE_SPECIFIED_ROW = 'the specified Row';
const A_STRING_SERIALIZATION_OF = 'a string serialization of';
const getTheContentOfDoc = (content = 0, theStore = 0) =>
  `the ${CONTENT[content]}content of${theStore ? ` ${THE_STORE}` : ''}`;
const getTheContentOfTheStoreDoc = (verb, content = 0, set = 0) =>
  `${VERBS[verb]} ${getTheContentOfDoc(content, 1)}${set ? ' when set' : ''}`;
const getRowTypeDoc = (tableId, set = 0) =>
  `${REPRESENTS} a Row when ${
    set ? 's' : 'g'
  }etting ${getTheContentOfDoc()} the '${tableId}' Table`;
const getIdsDoc = (idsNoun, parentNoun, sorted = 0) =>
  `Gets ${
    sorted ? 'sorted, paginated' : 'the'
  } Ids of the ${idsNoun}s in ${parentNoun}`;
const getForEachDoc = (childNoun, parentNoun) =>
  `Calls a function for each ${childNoun} in ${parentNoun}`;
const getHasDoc = (childNoun, parentNoun = THE_STORE) =>
  `Gets whether ${childNoun} exists in ${parentNoun}`;
const getCallbackDoc = (takes) => `A function that takes ${takes}`;
const getListenerTypeDoc = (childNoun, parentNoun = 0) =>
  `${A_FUNCTION_FOR} listening to changes to ${NOUNS[childNoun]} in ${NOUNS[parentNoun]}`;
const getListenerDoc = (childNoun, parentNoun, pluralChild = 0) =>
  `${REGISTERS_A_LISTENER} whenever ${childNoun} in ${parentNoun} change` +
  (pluralChild ? EMPTY_STRING : 's');
const getTableDoc = (tableId) => `the '${tableId}' Table`;
const getRowDoc = (tableId) =>
  `${THE_SPECIFIED_ROW} in ${getTableDoc(tableId)}`;
const getCellDoc = (cellId) => `the '${cellId}' Cell`;
const getValueDoc = (valueId) => `the '${valueId}' Value`;
const getTableContentDoc = (tableId, verb = 0) =>
  `${VERBS[verb]} ${getTheContentOfDoc()} ${getTableDoc(tableId)}`;
const getRowContentDoc = (tableId, verb = 0) =>
  `${VERBS[verb]} ${getTheContentOfDoc()} ${getRowDoc(tableId)}`;
const getCellContentDoc = (tableId, cellId, verb = 0) =>
  `${VERBS[verb]} ${getCellDoc(cellId)} for ${getRowDoc(tableId)}`;
const getValueContentDoc = (valueId, verb = 0) =>
  `${VERBS[verb]} ${getValueDoc(valueId)}`;
const VERBS = [
  'Gets',
  'Sets',
  'Sets part of',
  'Deletes',
  REPRESENTS,
  `Gets ${A_STRING_SERIALIZATION_OF}`,
  `Sets ${A_STRING_SERIALIZATION_OF}`,
  `${REGISTERS_A_LISTENER} whenever`,
];
const NOUNS = [
  THE_STORE,
  'Tables',
  'Table Ids',
  'a Table',
  'Row Ids',
  'a Row',
  'Cell Ids',
  'a Cell',
  'invalid Cell changes',
  'Values',
  'Value Ids',
  'a Value',
  'invalid Value changes',
];
const CONTENT = ['', 'tabular ', 'keyed value '];

const COMMON_IMPORTS = ['DoRollback', 'Id', 'IdOrNull', 'Ids', 'Json', 'Store'];
const storeMethod = (method, parameters = EMPTY_STRING, cast = EMPTY_STRING) =>
  `store.${method}(${parameters})${cast ? ` as ${cast}` : EMPTY_STRING}`;
const fluentStoreMethod = (method, parameters = EMPTY_STRING) =>
  `fluent(() => ${storeMethod(method, parameters)})`;
const storeListener = (
  method,
  beforeParameters = EMPTY_STRING,
  afterParameters = EMPTY_STRING,
) =>
  `store.${method}(${
    beforeParameters ? `${beforeParameters}, ` : EMPTY_STRING
  }proxy(${LISTENER})${
    afterParameters ? `, ${afterParameters}` : EMPTY_STRING
  })`;
const getStoreApi = (tablesSchema, valuesSchema, module) => {
  if (objIsEmpty(tablesSchema) && objIsEmpty(valuesSchema)) {
    return pairNew(EMPTY_STRING);
  }
  const [
    build,
    addImport,
    addType,
    addMethod,
    addFunction,
    addConstant,
    getImports,
    getTypes,
    getMethods,
    getConstants,
  ] = getCodeFunctions();
  const moduleDefinition = `./${camel(module)}.d`;
  const storeType = camel(module, 1);
  const storeInstance = camel(storeType);
  const createSteps = [];
  const tableTypes = mapNew();
  const mapTablesSchema = (callback) =>
    objMap(tablesSchema, (_, tableId) => {
      return callback(
        tableId,
        mapEnsure(tableTypes, tableId, () => {
          const table = camel(tableId, 1);
          return [
            addType(
              `${table}Table`,
              `{[rowId: Id]: ${table}Row}`,
              `${REPRESENTS} the '${tableId}' Table`,
            ),
            addType(
              `${table}Row`,
              `{${join(
                mapCellSchema(
                  tableId,
                  (cellId, type, defaultValue) =>
                    `'${cellId}'${
                      isUndefined(defaultValue) ? '?' : EMPTY_STRING
                    }: ${type};`,
                ),
                ' ',
              )}}`,
              getRowTypeDoc(tableId),
            ),
            addType(
              `${table}RowWhenSet`,
              `{${join(
                mapCellSchema(
                  tableId,
                  (cellId, type) => `'${cellId}'?: ${type};`,
                ),
                ' ',
              )}}`,
              getRowTypeDoc(tableId, 1),
            ),
            addType(
              `${table}CellId`,
              join(
                mapCellSchema(tableId, (cellId) => `'${cellId}'`),
                ' | ',
              ),
              `A Cell Id for the '${tableId}' Table`,
            ),
            addType(
              `${table}CellCallback`,
              `(...[cellId, cell]: ${join(
                mapCellSchema(
                  tableId,
                  (cellId, type) => `[cellId: '${cellId}', cell: ${type}]`,
                ),
                ' | ',
              )})${RETURNS_VOID}`,
              getCallbackDoc(
                `a Cell Id and value from a Row in the '${tableId}' Table`,
              ),
            ),
            addType(
              `${table}RowCallback`,
              `(rowId: Id, forEachCell: (cellCallback: ${table}CellCallback)${RETURNS_VOID})${RETURNS_VOID}`,
              getCallbackDoc(
                `a Row Id from the '${tableId}' Table, and a Cell iterator`,
              ),
            ),
          ];
        }),
        camel(tableId, 1),
        addConstant(snake(tableId), `'${tableId}'`),
      );
    });
  const mapCellSchema = (tableId, callback) =>
    objMap(tablesSchema[tableId], (cellSchema, cellId) =>
      callback(
        cellId,
        cellSchema[TYPE],
        cellSchema[DEFAULT],
        addConstant(snake(cellId), `'${cellId}'`),
        camel(cellId, 1),
      ),
    );
  const mapValuesSchema = (callback) =>
    objMap(valuesSchema, (valueSchema, valueId) =>
      callback(
        valueId,
        valueSchema[TYPE],
        valueSchema[DEFAULT],
        addConstant(snake(valueId), `'${valueId}'`),
        camel(valueId, 1),
      ),
    );
  addImport(
    1,
    moduleDefinition,
    storeType,
    `create${storeType} as create${storeType}Decl`,
  );
  if (!objIsEmpty(tablesSchema)) {
    const tablesType = addType(
      'Tables',
      `{${join(
        mapTablesSchema(
          (tableId, tableTypes2) => `'${tableId}'?: ${tableTypes2[0]};`,
        ),
        ' ',
      )}}`,
      getTheContentOfTheStoreDoc(4, 1),
    );
    const tableIdType = addType(
      'TableId',
      join(
        mapTablesSchema((tableId) => `'${tableId}'`),
        ' | ',
      ),
      `A Table Id in ${THE_STORE}`,
    );
    const tableCallbackType = addType(
      'TableCallback',
      `(...[tableId, rowCallback]: ${join(
        mapTablesSchema(
          (tableId, tableTypes2) =>
            `[tableId: '${tableId}', forEachRow: (rowCallback: ${tableTypes2[5]})${RETURNS_VOID}]`,
        ),
        ' | ',
      )})${RETURNS_VOID}`,
      getCallbackDoc('a Table Id, and a Row iterator'),
    );
    const getCellChangeType = addType(
      'GetCellChange',
      `(...[tableId, rowId, cellId]: ${join(
        mapTablesSchema(
          (tableId, tableTypes2) =>
            `[tableId: '${tableId}', rowId: Id, cellId: ${tableTypes2[3]}]`,
        ),
        ' | ',
      )}) => CellChange`,
      `${A_FUNCTION_FOR} returning information about any Cell's changes during a transaction`,
    );
    const tablesListenerType = addType(
      'TablesListener',
      `(${storeInstance}: ${storeType}, getCellChange: ${getCellChangeType}${OR_UNDEFINED})${RETURNS_VOID}`,
      getListenerTypeDoc(1),
    );
    const tableIdsListenerType = addType(
      'TableIdsListener',
      `(${storeInstance}: ${storeType})${RETURNS_VOID}`,
      getListenerTypeDoc(2),
    );
    const tableListenerType = addType(
      'TableListener',
      `(${storeInstance}: ${storeType}, tableId: ${tableIdType}, getCellChange: ${getCellChangeType}${OR_UNDEFINED})${RETURNS_VOID}`,
      getListenerTypeDoc(3),
    );
    const rowIdsListenerType = addType(
      'RowIdsListener',
      `(${storeInstance}: ${storeType}, tableId: ${tableIdType})` +
        RETURNS_VOID,
      getListenerTypeDoc(4, 3),
    );
    const rowListenerType = addType(
      'RowListener',
      `(${storeInstance}: ${storeType}, tableId: ${tableIdType}, rowId: Id, getCellChange: ${getCellChangeType}${OR_UNDEFINED})${RETURNS_VOID}`,
      getListenerTypeDoc(5, 3),
    );
    const cellIdsListenerType = addType(
      'CellIdsListener',
      `(${storeInstance}: ${storeType}, tableId: ${tableIdType}, rowId: Id)` +
        RETURNS_VOID,
      getListenerTypeDoc(6, 5),
    );
    const cellListenerType = addType(
      'CellListener',
      `(...[${storeInstance}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${join(
        flat(
          mapTablesSchema((tableId) =>
            mapCellSchema(
              tableId,
              (cellId, type) =>
                `[${storeInstance}: ${storeType}, tableId: '${tableId}', rowId: Id, cellId: '${cellId}', newCell: ${type}${OR_UNDEFINED}, oldCell: ${type}${OR_UNDEFINED}, getCellChange: ${getCellChangeType} | undefined]`,
            ),
          ),
        ),
        ' | ',
      )})${RETURNS_VOID}`,
      getListenerTypeDoc(7, 5),
    );
    const invalidCellListenerType = addType(
      'InvalidCellListener',
      `(${storeInstance}: ${storeType}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${RETURNS_VOID}`,
      getListenerTypeDoc(8),
    );
    addMethod(
      `hasTables`,
      EMPTY_STRING,
      BOOLEAN,
      storeMethod('hasTables'),
      getHasDoc('any Table'),
    );
    addMethod(
      `getTables`,
      EMPTY_STRING,
      tablesType,
      storeMethod('getTables'),
      getTheContentOfTheStoreDoc(0, 1),
    );
    addMethod(
      `setTables`,
      `tables: ${tablesType}`,
      storeType,
      fluentStoreMethod('setTables', 'tables'),
      getTheContentOfTheStoreDoc(1, 1),
    );
    addMethod(
      `delTables`,
      EMPTY_STRING,
      storeType,
      fluentStoreMethod('delTables'),
      getTheContentOfTheStoreDoc(3, 1),
    );
    addMethod(
      `getTableIds`,
      EMPTY_STRING,
      `${tableIdType}[]`,
      storeMethod('getTableIds', EMPTY_STRING, `${tableIdType}[]`),
      getIdsDoc('Table', THE_STORE),
    );
    addMethod(
      'forEachTable',
      `tableCallback: ${tableCallbackType}`,
      'void',
      storeMethod('forEachTable', 'tableCallback as any'),
      getForEachDoc('Table', THE_STORE),
    );
    const mapCellTypes = mapNew();
    mapTablesSchema(
      (
        tableId,
        [
          tableType,
          rowType,
          rowWhenSetType,
          cellIdType,
          cellCallbackType,
          rowCallbackType,
        ],
        tableName,
        TABLE_ID,
      ) => {
        addImport(
          1,
          moduleDefinition,
          tableType,
          rowType,
          rowWhenSetType,
          cellIdType,
          cellCallbackType,
          rowCallbackType,
        );
        addMethod(
          `has${tableName}Table`,
          EMPTY_STRING,
          BOOLEAN,
          storeMethod('hasTable', TABLE_ID),
          getHasDoc(getTableDoc(tableId)),
        );
        addMethod(
          `get${tableName}Table`,
          EMPTY_STRING,
          tableType,
          storeMethod('getTable', TABLE_ID, tableType),
          getTableContentDoc(tableId),
        );
        addMethod(
          `set${tableName}Table`,
          `table: ${tableType}`,
          storeType,
          fluentStoreMethod('setTable', `${TABLE_ID}, table`),
          getTableContentDoc(tableId, 1),
        );
        addMethod(
          `del${tableName}Table`,
          EMPTY_STRING,
          storeType,
          fluentStoreMethod('delTable', TABLE_ID),
          getTableContentDoc(tableId, 3),
        );
        addMethod(
          `get${tableName}RowIds`,
          EMPTY_STRING,
          'Ids',
          storeMethod('getRowIds', TABLE_ID),
          getIdsDoc('Row', getTableDoc(tableId)),
        );
        addMethod(
          `get${tableName}SortedRowIds`,
          `cellId?: ${cellIdType}, descending?: boolean, offset?: number, limit?: number`,
          'Ids',
          storeMethod(
            'getSortedRowIds',
            `${TABLE_ID}, cellId, descending, offset, limit`,
          ),
          getIdsDoc('Row', getTableDoc(tableId), 1),
        );
        addMethod(
          `forEach${tableName}Row`,
          `rowCallback: ${rowCallbackType}`,
          'void',
          storeMethod('forEachRow', `${TABLE_ID}, rowCallback as any`),
          getForEachDoc('Row', getTableDoc(tableId)),
        );
        addMethod(
          `has${tableName}Row`,
          'rowId: Id',
          BOOLEAN,
          storeMethod('hasRow', `${TABLE_ID}, rowId`),
          getHasDoc(THE_SPECIFIED_ROW, getTableDoc(tableId)),
        );
        addMethod(
          `get${tableName}Row`,
          'rowId: Id',
          rowType,
          storeMethod('getRow', `${TABLE_ID}, rowId`, rowType),
          getRowContentDoc(tableId),
        );
        addMethod(
          `set${tableName}Row`,
          `rowId: Id, row: ${rowWhenSetType}`,
          storeType,
          fluentStoreMethod('setRow', `${TABLE_ID}, rowId, row`),
          getRowContentDoc(tableId, 1),
        );
        addMethod(
          `add${tableName}Row`,
          `row: ${rowWhenSetType}`,
          `Id${OR_UNDEFINED}`,
          storeMethod('addRow', `${TABLE_ID}, row`),
          `Adds a new Row to ${getTableDoc(tableId)}`,
        );
        addMethod(
          `set${tableName}PartialRow`,
          `rowId: Id, partialRow: ${rowWhenSetType}`,
          storeType,
          fluentStoreMethod('setPartialRow', `${TABLE_ID}, rowId, partialRow`),
          getRowContentDoc(tableId, 2),
        );
        addMethod(
          `del${tableName}Row`,
          `rowId: Id`,
          storeType,
          fluentStoreMethod('delRow', `${TABLE_ID}, rowId`),
          getRowContentDoc(tableId, 3),
        );
        addMethod(
          `get${tableName}CellIds`,
          'rowId: Id',
          `${cellIdType}[]`,
          storeMethod('getCellIds', `${TABLE_ID}, rowId`, `${cellIdType}[]`),
          getIdsDoc('Cell', getRowDoc(tableId)),
        );
        addMethod(
          `forEach${tableName}Cell`,
          `rowId: Id, cellCallback: ${cellCallbackType}`,
          'void',
          storeMethod('forEachCell', `${TABLE_ID}, rowId, cellCallback as any`),
          getForEachDoc('Cell', getRowDoc(tableId)),
        );
        mapCellSchema(
          tableId,
          (cellId, type, defaultValue, CELL_ID, cellName) => {
            const mapCellType = `Map${camel(type, 1)}`;
            mapSet(mapCellTypes, type, mapCellType);
            addMethod(
              `has${tableName}${cellName}Cell`,
              'rowId: Id',
              BOOLEAN,
              storeMethod('hasCell', `${TABLE_ID}, rowId, ${CELL_ID}`),
              getHasDoc(getCellDoc(cellId), getRowDoc(tableId)),
            );
            const returnCellType = `${type}${
              isUndefined(defaultValue) ? OR_UNDEFINED : EMPTY_STRING
            }`;
            addMethod(
              `get${tableName}${cellName}Cell`,
              'rowId: Id',
              returnCellType,
              storeMethod(
                'getCell',
                `${TABLE_ID}, rowId, ${CELL_ID}`,
                returnCellType,
              ),
              getCellContentDoc(tableId, cellId),
            );
            addMethod(
              `set${tableName}${cellName}Cell`,
              `rowId: Id, cell: ${type} | ${mapCellType}`,
              storeType,
              fluentStoreMethod(
                'setCell',
                `${TABLE_ID}, rowId, ${CELL_ID}, cell as any`,
              ),
              getCellContentDoc(tableId, cellId, 1),
            );
            addMethod(
              `del${tableName}${cellName}Cell`,
              `rowId: Id`,
              storeType,
              fluentStoreMethod('delCell', `${TABLE_ID}, rowId, ${CELL_ID}`),
              getCellContentDoc(tableId, cellId, 3),
            );
          },
        );
      },
    );
    addMethod(
      'getTablesJson',
      EMPTY_STRING,
      'Json',
      storeMethod('getTablesJson'),
      getTheContentOfTheStoreDoc(5, 1),
    );
    addMethod(
      'setTablesJson',
      'tablesJson: Json',
      storeType,
      fluentStoreMethod('setTablesJson', 'tablesJson'),
      getTheContentOfTheStoreDoc(6, 1),
    );
    addMethod(
      'addTablesListener',
      `${LISTENER}: ${tablesListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addTablesListener', EMPTY_STRING, 'mutator'),
      getTheContentOfTheStoreDoc(7, 1) + ' changes',
    );
    addMethod(
      'addTableIdsListener',
      `${LISTENER}: ${tableIdsListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addTableIdsListener', EMPTY_STRING, 'mutator'),
      getListenerDoc('the Table Ids', THE_STORE, 1),
    );
    addMethod(
      'addTableListener',
      `tableId: ${tableIdType} | null, ${LISTENER}: ${tableListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addTableListener', 'tableId', 'mutator'),
      getListenerDoc('a Table', THE_STORE),
    );
    addMethod(
      'addRowIdsListener',
      `tableId: ${tableIdType} | null, ${LISTENER}: ${rowIdsListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addRowIdsListener', 'tableId', 'mutator'),
      getListenerDoc('the Row Ids', 'a Table', 1),
    );
    addMethod(
      'addRowListener',
      `tableId: ${tableIdType} | null, rowId: IdOrNull, ${LISTENER}: ${rowListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addRowListener', 'tableId, rowId', 'mutator'),
      getListenerDoc('a Row', 'a Table'),
    );
    addMethod(
      'addCellIdsListener',
      `tableId: ${tableIdType} | null, rowId: IdOrNull, ${LISTENER}: ${cellIdsListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addCellIdsListener', 'tableId, rowId', 'mutator'),
      getListenerDoc('the Cell Ids', 'a Row', 1),
    );
    addMethod(
      'addCellListener',
      `tableId: ${tableIdType} | null, rowId: IdOrNull, cellId: ${join(
        mapTablesSchema((_, tableTypes2) => tableTypes2[3]),
        ' | ',
      )} | null, ${LISTENER}: ${cellListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addCellListener', 'tableId, rowId, cellId', 'mutator'),
      getListenerDoc('a Cell', 'a Row'),
    );
    addMethod(
      'addInvalidCellListener',
      `tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${LISTENER}: ${invalidCellListenerType}, mutator?: boolean`,
      'Id',
      storeListener(
        'addInvalidCellListener',
        'tableId, rowId, cellId',
        'mutator',
      ),
      `${REGISTERS_A_LISTENER} whenever an invalid Cell change was attempted`,
    );
    mapForEach(mapCellTypes, (type, mapCellType) =>
      addType(
        mapCellType,
        `(cell: ${type}${OR_UNDEFINED}) => ${type}`,
        `Takes a ${type} Cell value and returns another`,
      ),
    );
    addImport(
      1,
      moduleDefinition,
      tablesType,
      tableIdType,
      tableCallbackType,
      tablesListenerType,
      tableIdsListenerType,
      tableListenerType,
      rowIdsListenerType,
      rowListenerType,
      cellIdsListenerType,
      cellListenerType,
      invalidCellListenerType,
      ...collValues(mapCellTypes),
    );
    addImport(0, 'tinybase', 'CellChange');
    arrayPush(
      createSteps,
      '.setTablesSchema({',
      flat(
        mapTablesSchema((tableId, _, __, TABLE_ID) => [
          `[${TABLE_ID}]: {`,
          ...mapCellSchema(
            tableId,
            (_2, type, defaultValue, CELL_ID) =>
              `[${CELL_ID}]: {[${addConstant(
                snake(TYPE),
                `'${TYPE}'`,
              )}]: ${addConstant(snake(type), `'${type}'`)}${
                isUndefined(defaultValue)
                  ? EMPTY_STRING
                  : `, [${addConstant(snake(DEFAULT), `'${DEFAULT}'`)}]: ${
                      isString(defaultValue)
                        ? addConstant(snake(defaultValue), `'${defaultValue}'`)
                        : defaultValue
                    }`
              }},`,
          ),
          `},`,
        ]),
      ),
      '})',
    );
  }
  if (!objIsEmpty(valuesSchema)) {
    const valuesType = addType(
      'Values',
      `{${join(
        mapValuesSchema(
          (valueId, type, defaultValue) =>
            `'${valueId}'${
              isUndefined(defaultValue) ? '?' : EMPTY_STRING
            }: ${type};`,
        ),
        ' ',
      )}}`,
      getTheContentOfTheStoreDoc(4, 2),
    );
    const valuesWhenSetType = addType(
      'ValuesWhenSet',
      `{${join(
        mapValuesSchema((valueId, type) => `'${valueId}'?: ${type};`),
        ' ',
      )}}`,
      getTheContentOfTheStoreDoc(4, 2, 1),
    );
    const valueIdType = addType(
      'ValueId',
      join(
        mapValuesSchema((valueId) => `'${valueId}'`),
        ' | ',
      ),
      `A Value Id in ${THE_STORE}`,
    );
    const valueCallbackType = addType(
      'ValueCallback',
      `(...[valueId, rowCallback]: ${join(
        mapValuesSchema(
          (valueId, type) => `[valueId: '${valueId}', value: ${type}]`,
        ),
        ' | ',
      )})${RETURNS_VOID}`,
      getCallbackDoc('a Value Id, and value'),
    );
    const getValueChangeType = addType(
      'GetValueChange',
      `(valueId: ${valueIdType}) => ValueChange`,
      `${A_FUNCTION_FOR} returning information about any Value's changes during a transaction`,
    );
    const valuesListenerType = addType(
      'ValuesListener',
      `(${storeInstance}: ${storeType}, getValueChange: ${getValueChangeType}${OR_UNDEFINED})` +
        RETURNS_VOID,
      getListenerTypeDoc(9),
    );
    const valueIdsListenerType = addType(
      'ValueIdsListener',
      `(${storeInstance}: ${storeType})${RETURNS_VOID}`,
      getListenerTypeDoc(10),
    );
    const valueListenerType = addType(
      'ValueListener',
      `(...[${storeInstance}, valueId, newValue, oldValue, getValueChange]: ${join(
        mapValuesSchema(
          (valueId, type) =>
            `[${storeInstance}: ${storeType}, valueId: '${valueId}', newValue: ${type}${OR_UNDEFINED}, oldValue: ${type}${OR_UNDEFINED}, getValueChange: ${getValueChangeType} | undefined]`,
        ),
        ' | ',
      )})${RETURNS_VOID}`,
      getListenerTypeDoc(11),
    );
    const invalidValueListenerType = addType(
      'InvalidValueListener',
      `(${storeInstance}: ${storeType}, valueId: Id, invalidValues: any[])${RETURNS_VOID}`,
      getListenerTypeDoc(12),
    );
    addMethod(
      `hasValues`,
      EMPTY_STRING,
      BOOLEAN,
      storeMethod('hasValues'),
      getHasDoc('any Value'),
    );
    addMethod(
      `getValues`,
      EMPTY_STRING,
      valuesType,
      storeMethod('getValues', EMPTY_STRING, valuesType),
      getTheContentOfTheStoreDoc(0, 2),
    );
    addMethod(
      `setValues`,
      `values: ${valuesWhenSetType}`,
      storeType,
      fluentStoreMethod('setValues', 'values'),
      getTheContentOfTheStoreDoc(1, 2),
    );
    addMethod(
      `setPartialValues`,
      `partialValues: ${valuesWhenSetType}`,
      storeType,
      fluentStoreMethod('setPartialValues', 'partialValues'),
      getTheContentOfTheStoreDoc(2, 2),
    );
    addMethod(
      `delValues`,
      EMPTY_STRING,
      storeType,
      fluentStoreMethod('delValues'),
      getTheContentOfTheStoreDoc(3, 2),
    );
    addMethod(
      `getValueIds`,
      EMPTY_STRING,
      `${valueIdType}[]`,
      storeMethod('getValueIds', EMPTY_STRING, `${valueIdType}[]`),
      getIdsDoc('Value', THE_STORE),
    );
    addMethod(
      'forEachValue',
      `valueCallback: ${valueCallbackType}`,
      'void',
      storeMethod('forEachValue', 'valueCallback as any'),
      getForEachDoc('Value', THE_STORE),
    );
    mapValuesSchema((valueId, type, _, VALUE_ID, valueName) => {
      addMethod(
        `has${valueName}Value`,
        EMPTY_STRING,
        BOOLEAN,
        storeMethod('hasValue', VALUE_ID),
        getHasDoc(getValueDoc(valueId)),
      );
      addMethod(
        `get${valueName}Value`,
        EMPTY_STRING,
        type,
        storeMethod('getValue', VALUE_ID, type),
        getValueContentDoc(valueId),
      );
      addMethod(
        `set${valueName}Value`,
        `value: ${type}`,
        storeType,
        fluentStoreMethod('setValue', `${VALUE_ID}, value`),
        getValueContentDoc(valueId, 1),
      );
      addMethod(
        `del${valueName}Value`,
        EMPTY_STRING,
        storeType,
        fluentStoreMethod('delValue', VALUE_ID),
        getValueContentDoc(valueId, 3),
      );
    });
    addMethod(
      'getValuesJson',
      EMPTY_STRING,
      'Json',
      storeMethod('getValuesJson'),
      getTheContentOfTheStoreDoc(5, 2),
    );
    addMethod(
      'setValuesJson',
      'valuesJson: Json',
      storeType,
      fluentStoreMethod('setValuesJson', 'valuesJson'),
      getTheContentOfTheStoreDoc(6, 2),
    );
    addMethod(
      'addValuesListener',
      `${LISTENER}: ${valuesListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addValuesListener', EMPTY_STRING, 'mutator'),
      getTheContentOfTheStoreDoc(7, 2) + ' changes',
    );
    addMethod(
      'addValueIdsListener',
      `${LISTENER}: ${valueIdsListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addValueIdsListener', EMPTY_STRING, 'mutator'),
      getListenerDoc('the Value Ids', THE_STORE, 1),
    );
    addMethod(
      'addValueListener',
      `valueId: ${valueIdType} | null, ${LISTENER}: ${valueListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addValueListener', 'valueId', 'mutator'),
      getListenerDoc('a Value', THE_STORE),
    );
    addMethod(
      'addInvalidValueListener',
      `valueId: IdOrNull, ${LISTENER}: ${invalidValueListenerType}, mutator?: boolean`,
      'Id',
      storeListener('addInvalidValueListener', 'valueId', 'mutator'),
      `${REGISTERS_A_LISTENER} whenever an invalid Cell change was attempted`,
    );
    addImport(
      1,
      moduleDefinition,
      valuesType,
      valuesWhenSetType,
      valueIdType,
      valueCallbackType,
      valuesListenerType,
      valueIdsListenerType,
      valueListenerType,
      invalidValueListenerType,
    );
    addImport(0, 'tinybase', 'ValueChange');
    arrayPush(
      createSteps,
      '.setValuesSchema({',
      mapValuesSchema((valueId, type, defaultValue, VALUE_ID) => [
        `[${VALUE_ID}]: {[${addConstant(
          snake(TYPE),
          `'${TYPE}'`,
        )}]: ${addConstant(snake(type), `'${type}'`)}${
          isUndefined(defaultValue)
            ? EMPTY_STRING
            : `, [${addConstant(snake(DEFAULT), `'${DEFAULT}'`)}]: ${
                isString(defaultValue)
                  ? addConstant(snake(defaultValue), `'${defaultValue}'`)
                  : defaultValue
              }`
        }},`,
      ]),
      '})',
    );
  }
  addImport(0, 'tinybase', ...COMMON_IMPORTS);
  const transactionListenerType = addType(
    'TransactionListener',
    `(${storeInstance}: ${storeType}, cellsTouched: boolean, valuesTouched: boolean)${RETURNS_VOID}`,
    `${A_FUNCTION_FOR} listening to the completion of a transaction`,
  );
  addMethod(
    'getJson',
    EMPTY_STRING,
    'Json',
    storeMethod('getJson'),
    getTheContentOfTheStoreDoc(5),
  );
  addMethod(
    'setJson',
    'json: Json',
    storeType,
    fluentStoreMethod('setJson', 'json'),
    getTheContentOfTheStoreDoc(6),
  );
  addMethod(
    'transaction',
    'actions: () => Return, doRollback?: DoRollback',
    'Return',
    storeMethod('transaction', 'actions, doRollback'),
    'Execute a transaction to make multiple mutations',
    '<Return>',
  );
  addMethod(
    'startTransaction',
    EMPTY_STRING,
    storeType,
    fluentStoreMethod('startTransaction'),
    'Explicitly starts a transaction',
  );
  addMethod(
    'finishTransaction',
    'doRollback?: DoRollback,',
    storeType,
    fluentStoreMethod('finishTransaction', 'doRollback'),
    'Explicitly finishes a transaction',
  );
  addMethod(
    'addWillFinishTransactionListener',
    `${LISTENER}: ${transactionListenerType}`,
    'Id',
    storeListener('addWillFinishTransactionListener'),
    `${REGISTERS_A_LISTENER} just before ${THE_END_OF_THE_TRANSACTION}`,
  );
  addMethod(
    'addDidFinishTransactionListener',
    `${LISTENER}: ${transactionListenerType}`,
    'Id',
    storeListener('addDidFinishTransactionListener'),
    `${REGISTERS_A_LISTENER} just after ${THE_END_OF_THE_TRANSACTION}`,
  );
  addMethod(
    'callListener',
    `${LISTENER}Id: Id`,
    storeType,
    fluentStoreMethod('callListener', `${LISTENER}Id`),
    `Manually provoke a ${LISTENER} to be called`,
  );
  addMethod(
    'delListener',
    `${LISTENER}Id: Id`,
    storeType,
    fluentStoreMethod('delListener', `${LISTENER}Id`),
    `Remove a ${LISTENER} that was previously added to ${THE_STORE}`,
  );
  addMethod(
    'getStore',
    EMPTY_STRING,
    'Store',
    'store',
    `${VERBS[0]} the underlying Store object`,
  );
  addImport(1, 'tinybase', 'createStore', ...COMMON_IMPORTS);
  addImport(
    1,
    moduleDefinition,
    storeType,
    `create${storeType} as create${storeType}Decl`,
    transactionListenerType,
  );
  addConstant('store', ['createStore()', ...createSteps]);
  addFunction('fluent', 'actions: () => Store', [
    'actions();',
    `return ${storeInstance};`,
  ]);
  addFunction(
    'proxy',
    `${LISTENER}: any`,
    `(_: Store, ...args: any[]) => ${LISTENER}(${storeInstance}, ...args)`,
  );
  addConstant(storeInstance, ['{', ...getMethods(1), '}']);
  return [
    build(
      ...getImports(0),
      ...getTypes(),
      `${EXPORT} interface ${storeType} {`,
      ...getMethods(0),
      `}`,
      EMPTY_STRING,
      comment(`Creates a ${storeType} object`),
      `${EXPORT} function create${storeType}(): ${storeType};`,
    ),
    build(
      ...getImports(1),
      `${EXPORT} const create${storeType}: typeof create${storeType}Decl = () => {`,
      ...getConstants(),
      `return Object.freeze(${storeInstance});`,
      `};`,
    ),
  ];
};

const prettierConfig = {
  parser: 'typescript',
  singleQuote: true,
  trailingComma: 'all',
  bracketSpacing: false,
  jsdocSingleLineComment: false,
};
const createTools = getCreateFunction((store) => {
  const getStoreStats = (detail) => {
    let totalTables = 0;
    let totalRows = 0;
    let totalCells = 0;
    const tables = {};
    store.forEachTable((tableId, forEachRow) => {
      totalTables++;
      let tableRows = 0;
      let tableCells = 0;
      const rows = {};
      forEachRow((rowId, forEachCell) => {
        tableRows++;
        let rowCells = 0;
        forEachCell(() => rowCells++);
        tableCells += rowCells;
        if (detail) {
          rows[rowId] = {rowCells};
        }
      });
      totalRows += tableRows;
      totalCells += tableCells;
      if (detail) {
        tables[tableId] = {tableRows, tableCells, rows};
      }
    });
    return {
      totalTables,
      totalRows,
      totalCells,
      totalValues: arrayLength(store.getValueIds()),
      jsonLength: length(store.getJson()),
      ...(detail ? {detail: {tables}} : {}),
    };
  };
  const getStoreTablesSchema = () => {
    const tablesSchema = jsonParse(store.getTablesSchemaJson());
    if (
      !objIsEmpty(tablesSchema) ||
      arrayEvery(store.getTableIds(), (tableId) => {
        const rowIds = store.getRowIds(tableId);
        const cellsMeta = mapNew();
        if (
          arrayEvery(rowIds, (rowId) =>
            arrayEvery(store.getCellIds(tableId, rowId), (cellId) => {
              const value = store.getCell(tableId, rowId, cellId);
              const cellMeta = mapEnsure(cellsMeta, cellId, () => [
                getCellOrValueType(value),
                mapNew(),
                [0],
                0,
              ]);
              const [type, values, [maxCount]] = cellMeta;
              const count = mapEnsure(values, value, () => 0) + 1;
              if (count > maxCount) {
                cellMeta[2] = [count, value];
              }
              mapSet(values, value, count);
              cellMeta[3]++;
              return type == getCellOrValueType(value);
            }),
          )
        ) {
          tablesSchema[tableId] = {};
          collForEach(cellsMeta, ([type, , [, maxValue], count], cellId) => {
            tablesSchema[tableId][cellId] = {
              [TYPE]: type,
              ...(count == arrayLength(rowIds) ? {[DEFAULT]: maxValue} : {}),
            };
          });
          return 1;
        }
      })
    ) {
      return tablesSchema;
    }
    return {};
  };
  const getStoreValuesSchema = () => {
    const valuesSchema = jsonParse(store.getValuesSchemaJson());
    if (objIsEmpty(valuesSchema)) {
      store.forEachValue((valueId, value) => {
        valuesSchema[valueId] = {
          [TYPE]: getCellOrValueType(value),
        };
      });
    }
    return valuesSchema;
  };
  const getStoreApi$1 = (module) =>
    getStoreApi(getStoreTablesSchema(), getStoreValuesSchema(), module);
  const getPrettyStoreApi = async (module) => {
    let format;
    try {
      format = (await import('prettier')).format;
    } catch {
      format = (str) => str;
    }
    return arrayMap(getStoreApi$1(module), (file) =>
      formatJsDoc(format(file, prettierConfig)),
    );
  };
  const getStore = () => store;
  const tools = {
    getStoreStats,
    getStoreTablesSchema,
    getStoreValuesSchema,
    getStoreApi: getStoreApi$1,
    getPrettyStoreApi,
    getStore,
  };
  return objFreeze(tools);
});

export {createTools};
