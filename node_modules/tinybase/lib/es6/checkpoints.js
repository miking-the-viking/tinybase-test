const e=(e,n)=>e.includes(n),n=(e,n)=>e.forEach(n),l=e=>e.length,t=e=>0==l(e),r=(e,...n)=>e.push(...n),o=e=>e.pop(),s=e=>e.shift(),u=e=>null==e,i=(e,n,l)=>u(e)?null==l?void 0:l():n(e),d=(e,n)=>{var l;return null!=(l=null==e?void 0:e.has(n))&&l},a=e=>u(e)||0==(e=>e.size)(e),c=(e,n)=>null==e?void 0:e.forEach(n),h=(e,n)=>null==e?void 0:e.delete(n),v=e=>new Map(e),p=(e,n)=>null==e?void 0:e.get(n),C=(e,n,l)=>u(l)?(h(e,n),e):null==e?void 0:e.set(n,l),f=(e,n,l)=>(d(e,n)||C(e,n,l()),p(e,n)),g=(e,n,t,r,o=0)=>i((t?f:p)(e,n[o],o>l(n)-2?t:v),(s=>{if(o>l(n)-2)return(null==r?void 0:r(s))&&C(e,n[o]),s;const u=g(s,n,t,r,o+1);return a(s)&&C(e,n[o]),u})),k=e=>new Set(Array.isArray(e)||u(e)?e:[e]),L=/^\d+$/,w=Object.freeze,S=(S=>{const y=new WeakMap;return S=>(y.has(S)||y.set(S,(S=>{let y,z,E,V=100,A=v(),I=v(),M=1;const b=v(),j=v(),[x,B,F]=(e=>{let t;const[o,d]=(()=>{const e=[];let n=0;return[()=>{var l;return null!=(l=s(e))?l:""+n++},n=>{L.test(n)&&l(e)<1e3&&r(e,n)}]})(),f=v();return[(e,n,l,r=[],s=(()=>[]))=>{null!=t||(t=_);const u=o();var i,d;return C(f,u,[e,n,l,r,s]),d=u,null==(i=g(n,null!=l?l:[""],k))||i.add(d),u},(e,o,...s)=>n(((e,t=[""])=>{const o=[],s=(e,u)=>u==l(t)?r(o,e):null===t[u]?c(e,(e=>s(e,u+1))):n([t[u],null],(n=>s(p(e,n),u+1)));return s(e,0),o})(e,o),(e=>c(e,(e=>p(f,e)[0](t,...null!=o?o:[],...s))))),e=>i(p(f,e),(([,n,l])=>(g(n,null!=l?l:[""],void 0,(n=>(h(n,e),a(n)?1:0))),C(f,e),d(e),l))),e=>i(p(f,e),(([e,,r=[],o,s])=>{const i=(...d)=>{var a,c;const h=l(d);h==l(r)?e(t,...d,...s(d)):u(r[h])?n(null!=(c=null==(a=o[h])?void 0:a.call(o,...d))?c:[],(e=>i(...d,e))):i(...d,r[h])};i()}))]})(),O=v(),T=v(),W=[],$=[],m=(e,n)=>{M=0,S.transaction((()=>{const[l,t]=p(O,n);c(l,((n,l)=>c(n,((n,t)=>c(n,((n,r)=>((e,n,l,t,r)=>u(r)?e.delCell(n,l,t,!0):e.setCell(n,l,t,r))(S,l,t,r,n[e]))))))),c(t,((n,l)=>((e,n,l)=>u(l)?e.delValue(n):e.setValue(n,l))(S,l,n[e])))})),M=1},q=e=>{C(O,e),C(T,e),B(j,[e])},D=(e,t)=>n(((e,n)=>e.splice(0,n))(e,null!=t?t:l(e)),q),G=()=>D(W,l(W)-V),H=()=>i(y,(()=>{r(W,y),G(),D($),y=void 0,E=1})),J=()=>{y=o(W),E=1},K=S.addCellListener(null,null,null,((e,n,l,t,r,o)=>{if(M){H();const e=f(A,n,v),s=f(e,l,v),u=f(s,t,(()=>[o,void 0]));u[1]=r,u[0]===r&&a(C(s,t))&&a(C(e,l))&&a(C(A,n))&&J(),U()}})),N=S.addValueListener(null,((e,n,l,t)=>{if(M){H();const e=f(I,n,(()=>[t,void 0]));e[1]=l,e[0]===l&&a(C(I,n))&&J(),U()}})),P=(e="")=>(u(y)&&(y=""+z++,C(O,y,[A,I]),Y(y,e),A=v(),I=v(),E=1),y),Q=()=>{t(W)||(((e,...n)=>{e.unshift(...n)})($,P()),m(0,y),y=o(W),E=1)},R=()=>{t($)||(r(W,y),y=s($),m(1,y),E=1)},U=()=>{E&&(B(b),E=0)},X=e=>{const n=P(e);return U(),n},Y=(e,n)=>(Z(e)&&p(T,e)!==n&&(C(T,e,n),B(j,[e])),_),Z=e=>d(O,e),_={setSize:e=>(V=e,G(),_),addCheckpoint:X,setCheckpoint:Y,getStore:()=>S,getCheckpointIds:()=>[[...W],y,[...$]],forEachCheckpoint:e=>{return n=e,c(T,((e,l)=>n(l,e)));var n},hasCheckpoint:Z,getCheckpoint:e=>p(T,e),goBackward:()=>(Q(),U(),_),goForward:()=>(R(),U(),_),goTo:n=>{const l=e(W,n)?Q:e($,n)?R:null;for(;!u(l)&&n!=y;)l();return U(),_},addCheckpointIdsListener:e=>x(e,b),addCheckpointListener:(e,n)=>x(n,j,[e]),delListener:e=>(F(e),_),clear:()=>(D(W),D($),u(y)||q(y),y=void 0,z=0,X(),_),destroy:()=>{S.delListener(K),S.delListener(N)},getListenerStats:()=>({})};return w(_.clear())})(S)),y.get(S))})();export{S as createCheckpoints};
