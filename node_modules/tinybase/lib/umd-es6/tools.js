var e,a;e=this,a=function(e){"use strict";const a=e=>typeof e,l="",t=a(l),o=a(!0),n=a(0),s="type",r="default",d=(e,a)=>e.every(a),$=(e,a)=>e.sort(a),i=(e,a)=>e.forEach(a),u=(e,a)=>e.map(a),I=e=>e.length,c=e=>0==I(e),b=(e,...a)=>e.push(...a),w=e=>e.pop(),h=(e,...a)=>e.unshift(...a),g=e=>e.shift(),C=JSON.parse,f=isFinite,T=(e,a)=>e instanceof a,V=e=>null==e,v=e=>e==t||e==o,p=e=>a(e)==t,R=e=>Array.isArray(e),m=e=>{const l=a(e);return v(l)||l==n&&f(e)?l:void 0},y=(e,a)=>{var l;return null!=(l=null==e?void 0:e.has(a))&&l},L=e=>{var a;return[...null!=(a=null==e?void 0:e.values())?a:[]]},S=(e,a)=>null==e?void 0:e.forEach(a),k=(e,a)=>null==e?void 0:e.delete(a),J=e=>new Map(e),E=(e,a)=>null==e?void 0:e.get(a),O=(e,a)=>S(e,((e,l)=>a(l,e))),j=(e,a)=>{var l;return u([...null!=(l=null==e?void 0:e.entries())?l:[]],(([e,l])=>a(l,e)))},x=(e,a,l)=>V(l)?(k(e,a),e):null==e?void 0:e.set(a,l),A=(e,a,l)=>(y(e,a)||x(e,a,l()),E(e,a)),P=e=>new Set(R(e)||V(e)?e:[e]),D=(e,a)=>null==e?void 0:e.add(a),N=e=>[e,e],G=()=>[J(),J()],z=/[^A-Za-z]+/,F=/[^A-Za-z0-9]+/,W=/^( *)\/\*\* *(.*?) *\*\/$/gm,M=(e,a,l)=>e.substring(a,l),Z=e=>e.toUpperCase(),_=e=>e.toLowerCase(),B=(e,a,l,t=1)=>{const o=`${a}${1==t?"":t}`;return y(e,o)?B(e,a,l,t+1):(x(e,o,l),o)},Q=e=>e.replace(W,((e,a,l)=>{const t=77-U(a);return`${a}/**\n${l.replace(RegExp(`([^\\n]{1,${t}})(\\s|$)`,"g"),a+" * $1\n")}${a} */`})),U=e=>e.length,q=(e,a=l)=>e.join(a),H=e=>e.flat(1e3),K=(e,a=0)=>q(u(e.split(F),((e,l)=>(l>0||a?Z:_)(M(e,0,1))+M(e,1)))),X=e=>Z(q((e&&!z.test(e[0])?e:" "+e).split(F),"_")),Y=e=>`/** ${e}. */`,ee=()=>{const e=G(),a=J(),t=J(),o=J();return[(...e)=>q(H(e),"\n"),(a,l,...t)=>i(t,(t=>D(A(e[a],l,P),t))),(e,l,t)=>B(a,e,[l,t]),(e,a,l,o,n,s="")=>B(t,e,[a,l,o,n,s]),(e,a,l)=>B(o,e,R(l)?[`(${a}) => {`,l,"}"]:[`(${a}) => ${l}`]),(e,a)=>E(o,e)===a?e:B(o,e,a),a=>[...$(j(e[a],((e,a)=>`import {${q($(L(e)),", ")}} from '${a}';`))),l],()=>j(a,(([e,a],t)=>[Y(a),`export type ${t} = ${e};`,l])),e=>j(t,(([a,t,o,n,s],r)=>{const d=e?[`${r}: ${s}(${a}): ${t} => ${o},`]:[`${r}${s}(${a}): ${t};`];return e||h(d,Y(n)),b(d,l),d})),()=>j(o,((e,a)=>(e=R(e)?e:[e],b(e,w(e)+";"),[`const ${a} = ${g(e)}`,e,l])))]},ae=Object,le=ae.keys,te=ae.freeze,oe=e=>T(e,ae)&&e.constructor==ae,ne=(e,a)=>u(ae.entries(e),(([e,l])=>a(l,e))),se=e=>oe(e)&&c(le(e)),re=e=>{const a=new WeakMap;return l=>(a.has(l)||a.set(l,e(l)),a.get(l))},de="the Store",$e="A function for",ie="export",ue="listener",Ie=" | undefined",ce=`Registers a ${ue} that will be called`,be="Represents",we=" => void",he="the end of the transaction",ge="the specified Row",Ce="a string serialization of",fe=(e=0,a=0)=>`the ${Ne[e]}content of${a?" "+de:""}`,Te=(e,a=0,l=0)=>`${Pe[e]} ${fe(a,1)}${l?" when set":""}`,Ve=(e,a=0)=>`${be} a Row when ${a?"s":"g"}etting ${fe()} the '${e}' Table`,ve=(e,a,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in ${a}`,pe=(e,a)=>`Calls a function for each ${e} in ${a}`,Re=(e,a=de)=>`Gets whether ${e} exists in ${a}`,me=e=>"A function that takes "+e,ye=(e,a=0)=>`${$e} listening to changes to ${De[e]} in ${De[a]}`,Le=(e,a,t=0)=>`${ce} whenever ${e} in ${a} change`+(t?l:"s"),Se=e=>`the '${e}' Table`,ke=e=>`${ge} in ${Se(e)}`,Je=e=>`the '${e}' Cell`,Ee=e=>`the '${e}' Value`,Oe=(e,a=0)=>`${Pe[a]} ${fe()} ${Se(e)}`,je=(e,a=0)=>`${Pe[a]} ${fe()} ${ke(e)}`,xe=(e,a,l=0)=>`${Pe[l]} ${Je(a)} for ${ke(e)}`,Ae=(e,a=0)=>`${Pe[a]} ${Ee(e)}`,Pe=["Gets","Sets","Sets part of","Deletes",be,"Gets "+Ce,"Sets "+Ce,ce+" whenever"],De=[de,"Tables","Table Ids","a Table","Row Ids","a Row","Cell Ids","a Cell","invalid Cell changes","Values","Value Ids","a Value","invalid Value changes"],Ne=["","tabular ","keyed value "],Ge=["DoRollback","Id","IdOrNull","Ids","Json","Store"],ze=(e,a=l,t=l)=>`store.${e}(${a})${t?" as "+t:l}`,Fe=(e,a=l)=>`fluent(() => ${ze(e,a)})`,We=(e,a=l,t=l)=>`store.${e}(${a?a+", ":l}proxy(${ue})${t?", "+t:l})`,Me=(e,a,t)=>{if(se(e)&&se(a))return N(l);const[n,d,$,i,u,I,c,w,h,g]=ee(),C=`./${K(t)}.d`,f=K(t,1),T=K(f),v=[],R=J(),m=a=>ne(e,((e,t)=>a(t,A(R,t,(()=>{const e=K(t,1);return[$(e+"Table",`{[rowId: Id]: ${e}Row}`,`${be} the '${t}' Table`),$(e+"Row",`{${q(y(t,((e,a,t)=>`'${e}'${V(t)?"?":l}: ${a};`))," ")}}`,Ve(t)),$(e+"RowWhenSet",`{${q(y(t,((e,a)=>`'${e}'?: ${a};`))," ")}}`,Ve(t,1)),$(e+"CellId",q(y(t,(e=>`'${e}'`))," | "),`A Cell Id for the '${t}' Table`),$(e+"CellCallback",`(...[cellId, cell]: ${q(y(t,((e,a)=>`[cellId: '${e}', cell: ${a}]`))," | ")})${we}`,me(`a Cell Id and value from a Row in the '${t}' Table`)),$(e+"RowCallback",`(rowId: Id, forEachCell: (cellCallback: ${e}CellCallback)${we})${we}`,me(`a Row Id from the '${t}' Table, and a Cell iterator`))]})),K(t,1),I(X(t),`'${t}'`)))),y=(a,l)=>ne(e[a],((e,a)=>l(a,e[s],e[r],I(X(a),`'${a}'`),K(a,1)))),S=e=>ne(a,((a,l)=>e(l,a[s],a[r],I(X(l),`'${l}'`),K(l,1))));if(d(1,C,f,`create${f} as create${f}Decl`),!se(e)){const e=$("Tables",`{${q(m(((e,a)=>`'${e}'?: ${a[0]};`))," ")}}`,Te(4,1)),a=$("TableId",q(m((e=>`'${e}'`))," | "),"A Table Id in "+de),t=$("TableCallback",`(...[tableId, rowCallback]: ${q(m(((e,a)=>`[tableId: '${e}', forEachRow: (rowCallback: ${a[5]})${we}]`))," | ")})${we}`,me("a Table Id, and a Row iterator")),n=$("GetCellChange",`(...[tableId, rowId, cellId]: ${q(m(((e,a)=>`[tableId: '${e}', rowId: Id, cellId: ${a[3]}]`))," | ")}) => CellChange`,$e+" returning information about any Cell's changes during a transaction"),u=$("TablesListener",`(${T}: ${f}, getCellChange: ${n}${Ie})${we}`,ye(1)),c=$("TableIdsListener",`(${T}: ${f})${we}`,ye(2)),w=$("TableListener",`(${T}: ${f}, tableId: ${a}, getCellChange: ${n}${Ie})${we}`,ye(3)),h=$("RowIdsListener",`(${T}: ${f}, tableId: ${a})`+we,ye(4,3)),g=$("RowListener",`(${T}: ${f}, tableId: ${a}, rowId: Id, getCellChange: ${n}${Ie})${we}`,ye(5,3)),R=$("CellIdsListener",`(${T}: ${f}, tableId: ${a}, rowId: Id)`+we,ye(6,5)),S=$("CellListener",`(...[${T}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${q(H(m((e=>y(e,((a,l)=>`[${T}: ${f}, tableId: '${e}', rowId: Id, cellId: '${a}', newCell: ${l}${Ie}, oldCell: ${l}${Ie}, getCellChange: ${n} | undefined]`)))))," | ")})${we}`,ye(7,5)),k=$("InvalidCellListener",`(${T}: ${f}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${we}`,ye(8));i("hasTables",l,o,ze("hasTables"),Re("any Table")),i("getTables",l,e,ze("getTables"),Te(0,1)),i("setTables","tables: "+e,f,Fe("setTables","tables"),Te(1,1)),i("delTables",l,f,Fe("delTables"),Te(3,1)),i("getTableIds",l,a+"[]",ze("getTableIds",l,a+"[]"),ve("Table",de)),i("forEachTable","tableCallback: "+t,"void",ze("forEachTable","tableCallback as any"),pe("Table",de));const E=J();m(((e,[a,t,n,s,r,$],u,I)=>{d(1,C,a,t,n,s,r,$),i(`has${u}Table`,l,o,ze("hasTable",I),Re(Se(e))),i(`get${u}Table`,l,a,ze("getTable",I,a),Oe(e)),i(`set${u}Table`,"table: "+a,f,Fe("setTable",I+", table"),Oe(e,1)),i(`del${u}Table`,l,f,Fe("delTable",I),Oe(e,3)),i(`get${u}RowIds`,l,"Ids",ze("getRowIds",I),ve("Row",Se(e))),i(`get${u}SortedRowIds`,`cellId?: ${s}, descending?: boolean, offset?: number, limit?: number`,"Ids",ze("getSortedRowIds",I+", cellId, descending, offset, limit"),ve("Row",Se(e),1)),i(`forEach${u}Row`,"rowCallback: "+$,"void",ze("forEachRow",I+", rowCallback as any"),pe("Row",Se(e))),i(`has${u}Row`,"rowId: Id",o,ze("hasRow",I+", rowId"),Re(ge,Se(e))),i(`get${u}Row`,"rowId: Id",t,ze("getRow",I+", rowId",t),je(e)),i(`set${u}Row`,"rowId: Id, row: "+n,f,Fe("setRow",I+", rowId, row"),je(e,1)),i(`add${u}Row`,"row: "+n,"Id"+Ie,ze("addRow",I+", row"),"Adds a new Row to "+Se(e)),i(`set${u}PartialRow`,"rowId: Id, partialRow: "+n,f,Fe("setPartialRow",I+", rowId, partialRow"),je(e,2)),i(`del${u}Row`,"rowId: Id",f,Fe("delRow",I+", rowId"),je(e,3)),i(`get${u}CellIds`,"rowId: Id",s+"[]",ze("getCellIds",I+", rowId",s+"[]"),ve("Cell",ke(e))),i(`forEach${u}Cell`,"rowId: Id, cellCallback: "+r,"void",ze("forEachCell",I+", rowId, cellCallback as any"),pe("Cell",ke(e))),y(e,((a,t,n,s,r)=>{const d="Map"+K(t,1);x(E,t,d),i(`has${u}${r}Cell`,"rowId: Id",o,ze("hasCell",`${I}, rowId, ${s}`),Re(Je(a),ke(e)));const $=`${t}${V(n)?Ie:l}`;i(`get${u}${r}Cell`,"rowId: Id",$,ze("getCell",`${I}, rowId, ${s}`,$),xe(e,a)),i(`set${u}${r}Cell`,`rowId: Id, cell: ${t} | ${d}`,f,Fe("setCell",`${I}, rowId, ${s}, cell as any`),xe(e,a,1)),i(`del${u}${r}Cell`,"rowId: Id",f,Fe("delCell",`${I}, rowId, ${s}`),xe(e,a,3))}))})),i("getTablesJson",l,"Json",ze("getTablesJson"),Te(5,1)),i("setTablesJson","tablesJson: Json",f,Fe("setTablesJson","tablesJson"),Te(6,1)),i("addTablesListener",`${ue}: ${u}, mutator?: boolean`,"Id",We("addTablesListener",l,"mutator"),Te(7,1)+" changes"),i("addTableIdsListener",`${ue}: ${c}, mutator?: boolean`,"Id",We("addTableIdsListener",l,"mutator"),Le("the Table Ids",de,1)),i("addTableListener",`tableId: ${a} | null, ${ue}: ${w}, mutator?: boolean`,"Id",We("addTableListener","tableId","mutator"),Le("a Table",de)),i("addRowIdsListener",`tableId: ${a} | null, ${ue}: ${h}, mutator?: boolean`,"Id",We("addRowIdsListener","tableId","mutator"),Le("the Row Ids","a Table",1)),i("addRowListener",`tableId: ${a} | null, rowId: IdOrNull, ${ue}: ${g}, mutator?: boolean`,"Id",We("addRowListener","tableId, rowId","mutator"),Le("a Row","a Table")),i("addCellIdsListener",`tableId: ${a} | null, rowId: IdOrNull, ${ue}: ${R}, mutator?: boolean`,"Id",We("addCellIdsListener","tableId, rowId","mutator"),Le("the Cell Ids","a Row",1)),i("addCellListener",`tableId: ${a} | null, rowId: IdOrNull, cellId: ${q(m(((e,a)=>a[3]))," | ")} | null, ${ue}: ${S}, mutator?: boolean`,"Id",We("addCellListener","tableId, rowId, cellId","mutator"),Le("a Cell","a Row")),i("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${ue}: ${k}, mutator?: boolean`,"Id",We("addInvalidCellListener","tableId, rowId, cellId","mutator"),ce+" whenever an invalid Cell change was attempted"),O(E,((e,a)=>$(a,`(cell: ${e}${Ie}) => ${e}`,`Takes a ${e} Cell value and returns another`))),d(1,C,e,a,t,u,c,w,h,g,R,S,k,...L(E)),d(0,"tinybase","CellChange"),b(v,".setTablesSchema({",H(m(((e,a,t,o)=>[`[${o}]: {`,...y(e,((e,a,t,o)=>`[${o}]: {[${I(X(s),`'${s}'`)}]: ${I(X(a),`'${a}'`)}${V(t)?l:`, [${I(X(r),`'${r}'`)}]: ${p(t)?I(X(t),`'${t}'`):t}`}},`)),"},"]))),"})")}if(!se(a)){const e=$("Values",`{${q(S(((e,a,t)=>`'${e}'${V(t)?"?":l}: ${a};`))," ")}}`,Te(4,2)),a=$("ValuesWhenSet",`{${q(S(((e,a)=>`'${e}'?: ${a};`))," ")}}`,Te(4,2,1)),t=$("ValueId",q(S((e=>`'${e}'`))," | "),"A Value Id in "+de),n=$("ValueCallback",`(...[valueId, rowCallback]: ${q(S(((e,a)=>`[valueId: '${e}', value: ${a}]`))," | ")})${we}`,me("a Value Id, and value")),u=$("GetValueChange",`(valueId: ${t}) => ValueChange`,$e+" returning information about any Value's changes during a transaction"),c=$("ValuesListener",`(${T}: ${f}, getValueChange: ${u}${Ie})`+we,ye(9)),w=$("ValueIdsListener",`(${T}: ${f})${we}`,ye(10)),h=$("ValueListener",`(...[${T}, valueId, newValue, oldValue, getValueChange]: ${q(S(((e,a)=>`[${T}: ${f}, valueId: '${e}', newValue: ${a}${Ie}, oldValue: ${a}${Ie}, getValueChange: ${u} | undefined]`))," | ")})${we}`,ye(11)),g=$("InvalidValueListener",`(${T}: ${f}, valueId: Id, invalidValues: any[])${we}`,ye(12));i("hasValues",l,o,ze("hasValues"),Re("any Value")),i("getValues",l,e,ze("getValues",l,e),Te(0,2)),i("setValues","values: "+a,f,Fe("setValues","values"),Te(1,2)),i("setPartialValues","partialValues: "+a,f,Fe("setPartialValues","partialValues"),Te(2,2)),i("delValues",l,f,Fe("delValues"),Te(3,2)),i("getValueIds",l,t+"[]",ze("getValueIds",l,t+"[]"),ve("Value",de)),i("forEachValue","valueCallback: "+n,"void",ze("forEachValue","valueCallback as any"),pe("Value",de)),S(((e,a,t,n,s)=>{i(`has${s}Value`,l,o,ze("hasValue",n),Re(Ee(e))),i(`get${s}Value`,l,a,ze("getValue",n,a),Ae(e)),i(`set${s}Value`,"value: "+a,f,Fe("setValue",n+", value"),Ae(e,1)),i(`del${s}Value`,l,f,Fe("delValue",n),Ae(e,3))})),i("getValuesJson",l,"Json",ze("getValuesJson"),Te(5,2)),i("setValuesJson","valuesJson: Json",f,Fe("setValuesJson","valuesJson"),Te(6,2)),i("addValuesListener",`${ue}: ${c}, mutator?: boolean`,"Id",We("addValuesListener",l,"mutator"),Te(7,2)+" changes"),i("addValueIdsListener",`${ue}: ${w}, mutator?: boolean`,"Id",We("addValueIdsListener",l,"mutator"),Le("the Value Ids",de,1)),i("addValueListener",`valueId: ${t} | null, ${ue}: ${h}, mutator?: boolean`,"Id",We("addValueListener","valueId","mutator"),Le("a Value",de)),i("addInvalidValueListener",`valueId: IdOrNull, ${ue}: ${g}, mutator?: boolean`,"Id",We("addInvalidValueListener","valueId","mutator"),ce+" whenever an invalid Cell change was attempted"),d(1,C,e,a,t,n,c,w,h,g),d(0,"tinybase","ValueChange"),b(v,".setValuesSchema({",S(((e,a,t,o)=>[`[${o}]: {[${I(X(s),`'${s}'`)}]: ${I(X(a),`'${a}'`)}${V(t)?l:`, [${I(X(r),`'${r}'`)}]: ${p(t)?I(X(t),`'${t}'`):t}`}},`])),"})")}d(0,"tinybase",...Ge);const k=$("TransactionListener",`(${T}: ${f}, cellsTouched: boolean, valuesTouched: boolean)${we}`,$e+" listening to the completion of a transaction");return i("getJson",l,"Json",ze("getJson"),Te(5)),i("setJson","json: Json",f,Fe("setJson","json"),Te(6)),i("transaction","actions: () => Return, doRollback?: DoRollback","Return",ze("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),i("startTransaction",l,f,Fe("startTransaction"),"Explicitly starts a transaction"),i("finishTransaction","doRollback?: DoRollback,",f,Fe("finishTransaction","doRollback"),"Explicitly finishes a transaction"),i("addWillFinishTransactionListener",`${ue}: ${k}`,"Id",We("addWillFinishTransactionListener"),`${ce} just before ${he}`),i("addDidFinishTransactionListener",`${ue}: ${k}`,"Id",We("addDidFinishTransactionListener"),`${ce} just after ${he}`),i("callListener",ue+"Id: Id",f,Fe("callListener",ue+"Id"),`Manually provoke a ${ue} to be called`),i("delListener",ue+"Id: Id",f,Fe("delListener",ue+"Id"),`Remove a ${ue} that was previously added to ${de}`),i("getStore",l,"Store","store",Pe[0]+" the underlying Store object"),d(1,"tinybase","createStore",...Ge),d(1,C,f,`create${f} as create${f}Decl`,k),I("store",["createStore()",...v]),u("fluent","actions: () => Store",["actions();",`return ${T};`]),u("proxy",ue+": any",`(_: Store, ...args: any[]) => ${ue}(${T}, ...args)`),I(T,["{",...h(1),"}"]),[n(...c(0),...w(),`${ie} interface ${f} {`,...h(0),"}",l,Y(`Creates a ${f} object`),`${ie} function create${f}(): ${f};`),n(...c(1),`${ie} const create${f}: typeof create${f}Decl = () => {`,...g(),`return Object.freeze(${T});`,"};")]};var Ze=Object.defineProperty,_e=Object.getOwnPropertySymbols,Be=Object.prototype.hasOwnProperty,Qe=Object.prototype.propertyIsEnumerable,Ue=(e,a,l)=>a in e?Ze(e,a,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[a]=l,qe=(e,a)=>{for(var l in a||(a={}))Be.call(a,l)&&Ue(e,l,a[l]);if(_e)for(var l of _e(a))Qe.call(a,l)&&Ue(e,l,a[l]);return e},He=(e,a,l)=>new Promise(((t,o)=>{var n=e=>{try{r(l.next(e))}catch(e){o(e)}},s=e=>{try{r(l.throw(e))}catch(e){o(e)}},r=e=>e.done?t(e.value):Promise.resolve(e.value).then(n,s);r((l=l.apply(e,a)).next())}));const Ke={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Xe=re((e=>{const a=()=>{const a=C(e.getTablesSchemaJson());return!se(a)||d(e.getTableIds(),(l=>{const t=e.getRowIds(l),o=J();if(d(t,(a=>d(e.getCellIds(l,a),(t=>{const n=e.getCell(l,a,t),s=A(o,t,(()=>[m(n),J(),[0],0])),[r,d,[$]]=s,i=A(d,n,(()=>0))+1;return i>$&&(s[2]=[i,n]),x(d,n,i),s[3]++,r==m(n)})))))return a[l]={},S(o,(([e,,[,o],n],d)=>{a[l][d]=qe({[s]:e},n==I(t)?{[r]:o}:{})})),1}))?a:{}},l=()=>{const a=C(e.getValuesSchemaJson());return se(a)&&e.forEachValue(((e,l)=>{a[e]={[s]:m(l)}})),a},t=e=>Me(a(),l(),e),o=e=>He(void 0,null,(function*(){let a;try{a=(yield import("prettier")).format}catch(e){a=e=>e}return u(t(e),(e=>Q(a(e,Ke))))}));return te({getStoreStats:a=>{let l=0,t=0,o=0;const n={};return e.forEachTable(((e,s)=>{l++;let r=0,d=0;const $={};s(((e,l)=>{r++;let t=0;l((()=>t++)),d+=t,a&&($[e]={rowCells:t})})),t+=r,o+=d,a&&(n[e]={tableRows:r,tableCells:d,rows:$})})),qe({totalTables:l,totalRows:t,totalCells:o,totalValues:I(e.getValueIds()),jsonLength:U(e.getJson())},a?{detail:{tables:n}}:{})},getStoreTablesSchema:a,getStoreValuesSchema:l,getStoreApi:t,getPrettyStoreApi:o,getStore:()=>e})}));e.createTools=Xe},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBaseTools={});
