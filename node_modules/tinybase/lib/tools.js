const e=e=>typeof e,a="",l=e(a),t=e(!0),s=e(0),o="type",n="default",d=(e,a)=>e.every(a),r=(e,a)=>e.sort(a),$=(e,a)=>e.forEach(a),i=(e,a)=>e.map(a),u=e=>e.length,I=e=>0==u(e),c=(e,...a)=>e.push(...a),b=e=>e.pop(),w=(e,...a)=>e.unshift(...a),h=e=>e.shift(),g=JSON.parse,C=isFinite,V=(e,a)=>e instanceof a,T=e=>null==e,f=e=>e==l||e==t,R=a=>e(a)==l,m=e=>Array.isArray(e),v=a=>{const l=e(a);return f(l)||l==s&&C(a)?l:void 0},p=(e,a)=>e?.has(a)??!1,L=e=>[...e?.values()??[]],y=(e,a)=>e?.forEach(a),S=(e,a)=>e?.delete(a),k=e=>new Map(e),J=(e,a)=>e?.get(a),E=(e,a)=>y(e,((e,l)=>a(l,e))),A=(e,a)=>i([...e?.entries()??[]],(([e,l])=>a(l,e))),j=(e,a,l)=>T(l)?(S(e,a),e):e?.set(a,l),O=(e,a,l)=>(p(e,a)||j(e,a,l()),J(e,a)),x=e=>new Set(m(e)||T(e)?e:[e]),D=(e,a)=>e?.add(a),N=e=>[e,e],G=()=>[k(),k()],z=/[^A-Za-z]+/,F=/[^A-Za-z0-9]+/,P=/^( *)\/\*\* *(.*?) *\*\/$/gm,W=(e,a,l)=>e.substring(a,l),M=e=>e.toUpperCase(),Z=e=>e.toLowerCase(),_=(e,a,l,t=1)=>{const s=`${a}${1==t?"":t}`;return p(e,s)?_(e,a,l,t+1):(j(e,s,l),s)},Q=e=>e.replace(P,((e,a,l)=>{const t=77-U(a);return`${a}/**\n${l.replace(RegExp(`([^\\n]{1,${t}})(\\s|$)`,"g"),a+" * $1\n")}${a} */`})),U=e=>e.length,q=(e,l=a)=>e.join(l),B=e=>e.flat(1e3),H=(e,a=0)=>q(i(e.split(F),((e,l)=>(l>0||a?M:Z)(W(e,0,1))+W(e,1)))),K=e=>M(q((e&&!z.test(e[0])?e:" "+e).split(F),"_")),X=e=>`/** ${e}. */`,Y=()=>{const e=G(),l=k(),t=k(),s=k();return[(...e)=>q(B(e),"\n"),(a,l,...t)=>$(t,(t=>D(O(e[a],l,x),t))),(e,a,t)=>_(l,e,[a,t]),(e,a,l,s,o,n="")=>_(t,e,[a,l,s,o,n]),(e,a,l)=>_(s,e,m(l)?[`(${a}) => {`,l,"}"]:[`(${a}) => ${l}`]),(e,a)=>J(s,e)===a?e:_(s,e,a),l=>[...r(A(e[l],((e,a)=>`import {${q(r(L(e)),", ")}} from '${a}';`))),a],()=>A(l,(([e,l],t)=>[X(l),`export type ${t} = ${e};`,a])),e=>A(t,(([l,t,s,o,n],d)=>{const r=e?[`${d}: ${n}(${l}): ${t} => ${s},`]:[`${d}${n}(${l}): ${t};`];return e||w(r,X(o)),c(r,a),r})),()=>A(s,((e,l)=>(e=m(e)?e:[e],c(e,b(e)+";"),[`const ${l} = ${h(e)}`,e,a])))]},ee=Object,ae=ee.keys,le=ee.freeze,te=e=>V(e,ee)&&e.constructor==ee,se=(e,a)=>i(ee.entries(e),(([e,l])=>a(l,e))),oe=e=>te(e)&&I(ae(e)),ne="the Store",de="A function for",re="export",$e="listener",ie=" | undefined",ue=`Registers a ${$e} that will be called`,Ie="Represents",ce=" => void",be="the end of the transaction",we="the specified Row",he="a string serialization of",ge=(e=0,a=0)=>`the ${De[e]}content of${a?" "+ne:""}`,Ce=(e,a=0,l=0)=>`${Oe[e]} ${ge(a,1)}${l?" when set":""}`,Ve=(e,a=0)=>`${Ie} a Row when ${a?"s":"g"}etting ${ge()} the '${e}' Table`,Te=(e,a,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in ${a}`,fe=(e,a)=>`Calls a function for each ${e} in ${a}`,Re=(e,a=ne)=>`Gets whether ${e} exists in ${a}`,me=e=>"A function that takes "+e,ve=(e,a=0)=>`${de} listening to changes to ${xe[e]} in ${xe[a]}`,pe=(e,l,t=0)=>`${ue} whenever ${e} in ${l} change`+(t?a:"s"),Le=e=>`the '${e}' Table`,ye=e=>`${we} in ${Le(e)}`,Se=e=>`the '${e}' Cell`,ke=e=>`the '${e}' Value`,Je=(e,a=0)=>`${Oe[a]} ${ge()} ${Le(e)}`,Ee=(e,a=0)=>`${Oe[a]} ${ge()} ${ye(e)}`,Ae=(e,a,l=0)=>`${Oe[l]} ${Se(a)} for ${ye(e)}`,je=(e,a=0)=>`${Oe[a]} ${ke(e)}`,Oe=["Gets","Sets","Sets part of","Deletes",Ie,"Gets "+he,"Sets "+he,ue+" whenever"],xe=[ne,"Tables","Table Ids","a Table","Row Ids","a Row","Cell Ids","a Cell","invalid Cell changes","Values","Value Ids","a Value","invalid Value changes"],De=["","tabular ","keyed value "],Ne=["DoRollback","Id","IdOrNull","Ids","Json","Store"],Ge=(e,l=a,t=a)=>`store.${e}(${l})${t?" as "+t:a}`,ze=(e,l=a)=>`fluent(() => ${Ge(e,l)})`,Fe=(e,l=a,t=a)=>`store.${e}(${l?l+", ":a}proxy(${$e})${t?", "+t:a})`,Pe=(e,l,s)=>{if(oe(e)&&oe(l))return N(a);const[d,r,$,i,u,I,b,w,h,g]=Y(),C=`./${H(s)}.d`,V=H(s,1),f=H(V),m=[],v=k(),p=l=>se(e,((e,t)=>l(t,O(v,t,(()=>{const e=H(t,1);return[$(e+"Table",`{[rowId: Id]: ${e}Row}`,`${Ie} the '${t}' Table`),$(e+"Row",`{${q(y(t,((e,l,t)=>`'${e}'${T(t)?"?":a}: ${l};`))," ")}}`,Ve(t)),$(e+"RowWhenSet",`{${q(y(t,((e,a)=>`'${e}'?: ${a};`))," ")}}`,Ve(t,1)),$(e+"CellId",q(y(t,(e=>`'${e}'`))," | "),`A Cell Id for the '${t}' Table`),$(e+"CellCallback",`(...[cellId, cell]: ${q(y(t,((e,a)=>`[cellId: '${e}', cell: ${a}]`))," | ")})${ce}`,me(`a Cell Id and value from a Row in the '${t}' Table`)),$(e+"RowCallback",`(rowId: Id, forEachCell: (cellCallback: ${e}CellCallback)${ce})${ce}`,me(`a Row Id from the '${t}' Table, and a Cell iterator`))]})),H(t,1),I(K(t),`'${t}'`)))),y=(a,l)=>se(e[a],((e,a)=>l(a,e[o],e[n],I(K(a),`'${a}'`),H(a,1)))),S=e=>se(l,((a,l)=>e(l,a[o],a[n],I(K(l),`'${l}'`),H(l,1))));if(r(1,C,V,`create${V} as create${V}Decl`),!oe(e)){const e=$("Tables",`{${q(p(((e,a)=>`'${e}'?: ${a[0]};`))," ")}}`,Ce(4,1)),l=$("TableId",q(p((e=>`'${e}'`))," | "),"A Table Id in "+ne),s=$("TableCallback",`(...[tableId, rowCallback]: ${q(p(((e,a)=>`[tableId: '${e}', forEachRow: (rowCallback: ${a[5]})${ce}]`))," | ")})${ce}`,me("a Table Id, and a Row iterator")),d=$("GetCellChange",`(...[tableId, rowId, cellId]: ${q(p(((e,a)=>`[tableId: '${e}', rowId: Id, cellId: ${a[3]}]`))," | ")}) => CellChange`,de+" returning information about any Cell's changes during a transaction"),u=$("TablesListener",`(${f}: ${V}, getCellChange: ${d}${ie})${ce}`,ve(1)),b=$("TableIdsListener",`(${f}: ${V})${ce}`,ve(2)),w=$("TableListener",`(${f}: ${V}, tableId: ${l}, getCellChange: ${d}${ie})${ce}`,ve(3)),h=$("RowIdsListener",`(${f}: ${V}, tableId: ${l})`+ce,ve(4,3)),g=$("RowListener",`(${f}: ${V}, tableId: ${l}, rowId: Id, getCellChange: ${d}${ie})${ce}`,ve(5,3)),v=$("CellIdsListener",`(${f}: ${V}, tableId: ${l}, rowId: Id)`+ce,ve(6,5)),S=$("CellListener",`(...[${f}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${q(B(p((e=>y(e,((a,l)=>`[${f}: ${V}, tableId: '${e}', rowId: Id, cellId: '${a}', newCell: ${l}${ie}, oldCell: ${l}${ie}, getCellChange: ${d} | undefined]`)))))," | ")})${ce}`,ve(7,5)),J=$("InvalidCellListener",`(${f}: ${V}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${ce}`,ve(8));i("hasTables",a,t,Ge("hasTables"),Re("any Table")),i("getTables",a,e,Ge("getTables"),Ce(0,1)),i("setTables","tables: "+e,V,ze("setTables","tables"),Ce(1,1)),i("delTables",a,V,ze("delTables"),Ce(3,1)),i("getTableIds",a,l+"[]",Ge("getTableIds",a,l+"[]"),Te("Table",ne)),i("forEachTable","tableCallback: "+s,"void",Ge("forEachTable","tableCallback as any"),fe("Table",ne));const A=k();p(((e,[l,s,o,n,d,$],u,I)=>{r(1,C,l,s,o,n,d,$),i(`has${u}Table`,a,t,Ge("hasTable",I),Re(Le(e))),i(`get${u}Table`,a,l,Ge("getTable",I,l),Je(e)),i(`set${u}Table`,"table: "+l,V,ze("setTable",I+", table"),Je(e,1)),i(`del${u}Table`,a,V,ze("delTable",I),Je(e,3)),i(`get${u}RowIds`,a,"Ids",Ge("getRowIds",I),Te("Row",Le(e))),i(`get${u}SortedRowIds`,`cellId?: ${n}, descending?: boolean, offset?: number, limit?: number`,"Ids",Ge("getSortedRowIds",I+", cellId, descending, offset, limit"),Te("Row",Le(e),1)),i(`forEach${u}Row`,"rowCallback: "+$,"void",Ge("forEachRow",I+", rowCallback as any"),fe("Row",Le(e))),i(`has${u}Row`,"rowId: Id",t,Ge("hasRow",I+", rowId"),Re(we,Le(e))),i(`get${u}Row`,"rowId: Id",s,Ge("getRow",I+", rowId",s),Ee(e)),i(`set${u}Row`,"rowId: Id, row: "+o,V,ze("setRow",I+", rowId, row"),Ee(e,1)),i(`add${u}Row`,"row: "+o,"Id"+ie,Ge("addRow",I+", row"),"Adds a new Row to "+Le(e)),i(`set${u}PartialRow`,"rowId: Id, partialRow: "+o,V,ze("setPartialRow",I+", rowId, partialRow"),Ee(e,2)),i(`del${u}Row`,"rowId: Id",V,ze("delRow",I+", rowId"),Ee(e,3)),i(`get${u}CellIds`,"rowId: Id",n+"[]",Ge("getCellIds",I+", rowId",n+"[]"),Te("Cell",ye(e))),i(`forEach${u}Cell`,"rowId: Id, cellCallback: "+d,"void",Ge("forEachCell",I+", rowId, cellCallback as any"),fe("Cell",ye(e))),y(e,((l,s,o,n,d)=>{const r="Map"+H(s,1);j(A,s,r),i(`has${u}${d}Cell`,"rowId: Id",t,Ge("hasCell",`${I}, rowId, ${n}`),Re(Se(l),ye(e)));const $=`${s}${T(o)?ie:a}`;i(`get${u}${d}Cell`,"rowId: Id",$,Ge("getCell",`${I}, rowId, ${n}`,$),Ae(e,l)),i(`set${u}${d}Cell`,`rowId: Id, cell: ${s} | ${r}`,V,ze("setCell",`${I}, rowId, ${n}, cell as any`),Ae(e,l,1)),i(`del${u}${d}Cell`,"rowId: Id",V,ze("delCell",`${I}, rowId, ${n}`),Ae(e,l,3))}))})),i("getTablesJson",a,"Json",Ge("getTablesJson"),Ce(5,1)),i("setTablesJson","tablesJson: Json",V,ze("setTablesJson","tablesJson"),Ce(6,1)),i("addTablesListener",`${$e}: ${u}, mutator?: boolean`,"Id",Fe("addTablesListener",a,"mutator"),Ce(7,1)+" changes"),i("addTableIdsListener",`${$e}: ${b}, mutator?: boolean`,"Id",Fe("addTableIdsListener",a,"mutator"),pe("the Table Ids",ne,1)),i("addTableListener",`tableId: ${l} | null, ${$e}: ${w}, mutator?: boolean`,"Id",Fe("addTableListener","tableId","mutator"),pe("a Table",ne)),i("addRowIdsListener",`tableId: ${l} | null, ${$e}: ${h}, mutator?: boolean`,"Id",Fe("addRowIdsListener","tableId","mutator"),pe("the Row Ids","a Table",1)),i("addRowListener",`tableId: ${l} | null, rowId: IdOrNull, ${$e}: ${g}, mutator?: boolean`,"Id",Fe("addRowListener","tableId, rowId","mutator"),pe("a Row","a Table")),i("addCellIdsListener",`tableId: ${l} | null, rowId: IdOrNull, ${$e}: ${v}, mutator?: boolean`,"Id",Fe("addCellIdsListener","tableId, rowId","mutator"),pe("the Cell Ids","a Row",1)),i("addCellListener",`tableId: ${l} | null, rowId: IdOrNull, cellId: ${q(p(((e,a)=>a[3]))," | ")} | null, ${$e}: ${S}, mutator?: boolean`,"Id",Fe("addCellListener","tableId, rowId, cellId","mutator"),pe("a Cell","a Row")),i("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${$e}: ${J}, mutator?: boolean`,"Id",Fe("addInvalidCellListener","tableId, rowId, cellId","mutator"),ue+" whenever an invalid Cell change was attempted"),E(A,((e,a)=>$(a,`(cell: ${e}${ie}) => ${e}`,`Takes a ${e} Cell value and returns another`))),r(1,C,e,l,s,u,b,w,h,g,v,S,J,...L(A)),r(0,"tinybase","CellChange"),c(m,".setTablesSchema({",B(p(((e,l,t,s)=>[`[${s}]: {`,...y(e,((e,l,t,s)=>`[${s}]: {[${I(K(o),`'${o}'`)}]: ${I(K(l),`'${l}'`)}${T(t)?a:`, [${I(K(n),`'${n}'`)}]: ${R(t)?I(K(t),`'${t}'`):t}`}},`)),"},"]))),"})")}if(!oe(l)){const e=$("Values",`{${q(S(((e,l,t)=>`'${e}'${T(t)?"?":a}: ${l};`))," ")}}`,Ce(4,2)),l=$("ValuesWhenSet",`{${q(S(((e,a)=>`'${e}'?: ${a};`))," ")}}`,Ce(4,2,1)),s=$("ValueId",q(S((e=>`'${e}'`))," | "),"A Value Id in "+ne),d=$("ValueCallback",`(...[valueId, rowCallback]: ${q(S(((e,a)=>`[valueId: '${e}', value: ${a}]`))," | ")})${ce}`,me("a Value Id, and value")),u=$("GetValueChange",`(valueId: ${s}) => ValueChange`,de+" returning information about any Value's changes during a transaction"),b=$("ValuesListener",`(${f}: ${V}, getValueChange: ${u}${ie})`+ce,ve(9)),w=$("ValueIdsListener",`(${f}: ${V})${ce}`,ve(10)),h=$("ValueListener",`(...[${f}, valueId, newValue, oldValue, getValueChange]: ${q(S(((e,a)=>`[${f}: ${V}, valueId: '${e}', newValue: ${a}${ie}, oldValue: ${a}${ie}, getValueChange: ${u} | undefined]`))," | ")})${ce}`,ve(11)),g=$("InvalidValueListener",`(${f}: ${V}, valueId: Id, invalidValues: any[])${ce}`,ve(12));i("hasValues",a,t,Ge("hasValues"),Re("any Value")),i("getValues",a,e,Ge("getValues",a,e),Ce(0,2)),i("setValues","values: "+l,V,ze("setValues","values"),Ce(1,2)),i("setPartialValues","partialValues: "+l,V,ze("setPartialValues","partialValues"),Ce(2,2)),i("delValues",a,V,ze("delValues"),Ce(3,2)),i("getValueIds",a,s+"[]",Ge("getValueIds",a,s+"[]"),Te("Value",ne)),i("forEachValue","valueCallback: "+d,"void",Ge("forEachValue","valueCallback as any"),fe("Value",ne)),S(((e,l,s,o,n)=>{i(`has${n}Value`,a,t,Ge("hasValue",o),Re(ke(e))),i(`get${n}Value`,a,l,Ge("getValue",o,l),je(e)),i(`set${n}Value`,"value: "+l,V,ze("setValue",o+", value"),je(e,1)),i(`del${n}Value`,a,V,ze("delValue",o),je(e,3))})),i("getValuesJson",a,"Json",Ge("getValuesJson"),Ce(5,2)),i("setValuesJson","valuesJson: Json",V,ze("setValuesJson","valuesJson"),Ce(6,2)),i("addValuesListener",`${$e}: ${b}, mutator?: boolean`,"Id",Fe("addValuesListener",a,"mutator"),Ce(7,2)+" changes"),i("addValueIdsListener",`${$e}: ${w}, mutator?: boolean`,"Id",Fe("addValueIdsListener",a,"mutator"),pe("the Value Ids",ne,1)),i("addValueListener",`valueId: ${s} | null, ${$e}: ${h}, mutator?: boolean`,"Id",Fe("addValueListener","valueId","mutator"),pe("a Value",ne)),i("addInvalidValueListener",`valueId: IdOrNull, ${$e}: ${g}, mutator?: boolean`,"Id",Fe("addInvalidValueListener","valueId","mutator"),ue+" whenever an invalid Cell change was attempted"),r(1,C,e,l,s,d,b,w,h,g),r(0,"tinybase","ValueChange"),c(m,".setValuesSchema({",S(((e,l,t,s)=>[`[${s}]: {[${I(K(o),`'${o}'`)}]: ${I(K(l),`'${l}'`)}${T(t)?a:`, [${I(K(n),`'${n}'`)}]: ${R(t)?I(K(t),`'${t}'`):t}`}},`])),"})")}r(0,"tinybase",...Ne);const J=$("TransactionListener",`(${f}: ${V}, cellsTouched: boolean, valuesTouched: boolean)${ce}`,de+" listening to the completion of a transaction");return i("getJson",a,"Json",Ge("getJson"),Ce(5)),i("setJson","json: Json",V,ze("setJson","json"),Ce(6)),i("transaction","actions: () => Return, doRollback?: DoRollback","Return",Ge("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),i("startTransaction",a,V,ze("startTransaction"),"Explicitly starts a transaction"),i("finishTransaction","doRollback?: DoRollback,",V,ze("finishTransaction","doRollback"),"Explicitly finishes a transaction"),i("addWillFinishTransactionListener",`${$e}: ${J}`,"Id",Fe("addWillFinishTransactionListener"),`${ue} just before ${be}`),i("addDidFinishTransactionListener",`${$e}: ${J}`,"Id",Fe("addDidFinishTransactionListener"),`${ue} just after ${be}`),i("callListener",$e+"Id: Id",V,ze("callListener",$e+"Id"),`Manually provoke a ${$e} to be called`),i("delListener",$e+"Id: Id",V,ze("delListener",$e+"Id"),`Remove a ${$e} that was previously added to ${ne}`),i("getStore",a,"Store","store",Oe[0]+" the underlying Store object"),r(1,"tinybase","createStore",...Ne),r(1,C,V,`create${V} as create${V}Decl`,J),I("store",["createStore()",...m]),u("fluent","actions: () => Store",["actions();",`return ${f};`]),u("proxy",$e+": any",`(_: Store, ...args: any[]) => ${$e}(${f}, ...args)`),I(f,["{",...h(1),"}"]),[d(...b(0),...w(),`${re} interface ${V} {`,...h(0),"}",a,X(`Creates a ${V} object`),`${re} function create${V}(): ${V};`),d(...b(1),`${re} const create${V}: typeof create${V}Decl = () => {`,...g(),`return Object.freeze(${f});`,"};")]},We={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Me=(e=>{const a=new WeakMap;return l=>(a.has(l)||a.set(l,e(l)),a.get(l))})((e=>{const a=()=>{const a=g(e.getTablesSchemaJson());return!oe(a)||d(e.getTableIds(),(l=>{const t=e.getRowIds(l),s=k();if(d(t,(a=>d(e.getCellIds(l,a),(t=>{const o=e.getCell(l,a,t),n=O(s,t,(()=>[v(o),k(),[0],0])),[d,r,[$]]=n,i=O(r,o,(()=>0))+1;return i>$&&(n[2]=[i,o]),j(r,o,i),n[3]++,d==v(o)})))))return a[l]={},y(s,(([e,,[,s],d],r)=>{a[l][r]={[o]:e,...d==u(t)?{[n]:s}:{}}})),1}))?a:{}},l=()=>{const a=g(e.getValuesSchemaJson());return oe(a)&&e.forEachValue(((e,l)=>{a[e]={[o]:v(l)}})),a},t=e=>Pe(a(),l(),e),s=async e=>{let a;try{a=(await import("prettier")).format}catch{a=e=>e}return i(t(e),(e=>Q(a(e,We))))};return le({getStoreStats:a=>{let l=0,t=0,s=0;const o={};return e.forEachTable(((e,n)=>{l++;let d=0,r=0;const $={};n(((e,l)=>{d++;let t=0;l((()=>t++)),r+=t,a&&($[e]={rowCells:t})})),t+=d,s+=r,a&&(o[e]={tableRows:d,tableCells:r,rows:$})})),{totalTables:l,totalRows:t,totalCells:s,totalValues:u(e.getValueIds()),jsonLength:U(e.getJson()),...a?{detail:{tables:o}}:{}}},getStoreTablesSchema:a,getStoreValuesSchema:l,getStoreApi:t,getPrettyStoreApi:s,getStore:()=>e})}));export{Me as createTools};
