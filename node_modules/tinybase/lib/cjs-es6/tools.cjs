"use strict";const e=e=>typeof e,a="",l=e(a),t=e(!0),o=e(0),s="type",n="default",r=(e,a)=>e.every(a),d=(e,a)=>e.sort(a),$=(e,a)=>e.forEach(a),i=(e,a)=>e.map(a),u=e=>e.length,I=e=>0==u(e),c=(e,...a)=>e.push(...a),b=e=>e.pop(),w=(e,...a)=>e.unshift(...a),h=e=>e.shift(),g=JSON.parse,C=isFinite,T=(e,a)=>e instanceof a,V=e=>null==e,v=e=>e==l||e==t,f=a=>e(a)==l,R=e=>Array.isArray(e),m=a=>{const l=e(a);return v(l)||l==o&&C(a)?l:void 0},p=(e,a)=>{var l;return null!=(l=null==e?void 0:e.has(a))&&l},L=e=>{var a;return[...null!=(a=null==e?void 0:e.values())?a:[]]},y=(e,a)=>null==e?void 0:e.forEach(a),S=(e,a)=>null==e?void 0:e.delete(a),k=e=>new Map(e),J=(e,a)=>null==e?void 0:e.get(a),E=(e,a)=>y(e,((e,l)=>a(l,e))),O=(e,a)=>{var l;return i([...null!=(l=null==e?void 0:e.entries())?l:[]],(([e,l])=>a(l,e)))},j=(e,a,l)=>V(l)?(S(e,a),e):null==e?void 0:e.set(a,l),x=(e,a,l)=>(p(e,a)||j(e,a,l()),J(e,a)),A=e=>new Set(R(e)||V(e)?e:[e]),P=(e,a)=>null==e?void 0:e.add(a),D=e=>[e,e],N=()=>[k(),k()],G=/[^A-Za-z]+/,z=/[^A-Za-z0-9]+/,F=/^( *)\/\*\* *(.*?) *\*\/$/gm,W=(e,a,l)=>e.substring(a,l),M=e=>e.toUpperCase(),Z=e=>e.toLowerCase(),_=(e,a,l,t=1)=>{const o=`${a}${1==t?"":t}`;return p(e,o)?_(e,a,l,t+1):(j(e,o,l),o)},Q=e=>e.replace(F,((e,a,l)=>{const t=77-U(a);return`${a}/**\n${l.replace(RegExp(`([^\\n]{1,${t}})(\\s|$)`,"g"),a+" * $1\n")}${a} */`})),U=e=>e.length,q=(e,l=a)=>e.join(l),B=e=>e.flat(1e3),H=(e,a=0)=>q(i(e.split(z),((e,l)=>(l>0||a?M:Z)(W(e,0,1))+W(e,1)))),K=e=>M(q((e&&!G.test(e[0])?e:" "+e).split(z),"_")),X=e=>`/** ${e}. */`,Y=()=>{const e=N(),l=k(),t=k(),o=k();return[(...e)=>q(B(e),"\n"),(a,l,...t)=>$(t,(t=>P(x(e[a],l,A),t))),(e,a,t)=>_(l,e,[a,t]),(e,a,l,o,s,n="")=>_(t,e,[a,l,o,s,n]),(e,a,l)=>_(o,e,R(l)?[`(${a}) => {`,l,"}"]:[`(${a}) => ${l}`]),(e,a)=>J(o,e)===a?e:_(o,e,a),l=>[...d(O(e[l],((e,a)=>`import {${q(d(L(e)),", ")}} from '${a}';`))),a],()=>O(l,(([e,l],t)=>[X(l),`export type ${t} = ${e};`,a])),e=>O(t,(([l,t,o,s,n],r)=>{const d=e?[`${r}: ${n}(${l}): ${t} => ${o},`]:[`${r}${n}(${l}): ${t};`];return e||w(d,X(s)),c(d,a),d})),()=>O(o,((e,l)=>(e=R(e)?e:[e],c(e,b(e)+";"),[`const ${l} = ${h(e)}`,e,a])))]},ee=Object,ae=ee.keys,le=ee.freeze,te=e=>T(e,ee)&&e.constructor==ee,oe=(e,a)=>i(ee.entries(e),(([e,l])=>a(l,e))),se=e=>te(e)&&I(ae(e)),ne=e=>{const a=new WeakMap;return l=>(a.has(l)||a.set(l,e(l)),a.get(l))},re="the Store",de="A function for",$e="export",ie="listener",ue=" | undefined",Ie=`Registers a ${ie} that will be called`,ce="Represents",be=" => void",we="the end of the transaction",he="the specified Row",ge="a string serialization of",Ce=(e=0,a=0)=>`the ${De[e]}content of${a?" "+re:""}`,Te=(e,a=0,l=0)=>`${Ae[e]} ${Ce(a,1)}${l?" when set":""}`,Ve=(e,a=0)=>`${ce} a Row when ${a?"s":"g"}etting ${Ce()} the '${e}' Table`,ve=(e,a,l=0)=>`Gets ${l?"sorted, paginated":"the"} Ids of the ${e}s in ${a}`,fe=(e,a)=>`Calls a function for each ${e} in ${a}`,Re=(e,a=re)=>`Gets whether ${e} exists in ${a}`,me=e=>"A function that takes "+e,pe=(e,a=0)=>`${de} listening to changes to ${Pe[e]} in ${Pe[a]}`,Le=(e,l,t=0)=>`${Ie} whenever ${e} in ${l} change`+(t?a:"s"),ye=e=>`the '${e}' Table`,Se=e=>`${he} in ${ye(e)}`,ke=e=>`the '${e}' Cell`,Je=e=>`the '${e}' Value`,Ee=(e,a=0)=>`${Ae[a]} ${Ce()} ${ye(e)}`,Oe=(e,a=0)=>`${Ae[a]} ${Ce()} ${Se(e)}`,je=(e,a,l=0)=>`${Ae[l]} ${ke(a)} for ${Se(e)}`,xe=(e,a=0)=>`${Ae[a]} ${Je(e)}`,Ae=["Gets","Sets","Sets part of","Deletes",ce,"Gets "+ge,"Sets "+ge,Ie+" whenever"],Pe=[re,"Tables","Table Ids","a Table","Row Ids","a Row","Cell Ids","a Cell","invalid Cell changes","Values","Value Ids","a Value","invalid Value changes"],De=["","tabular ","keyed value "],Ne=["DoRollback","Id","IdOrNull","Ids","Json","Store"],Ge=(e,l=a,t=a)=>`store.${e}(${l})${t?" as "+t:a}`,ze=(e,l=a)=>`fluent(() => ${Ge(e,l)})`,Fe=(e,l=a,t=a)=>`store.${e}(${l?l+", ":a}proxy(${ie})${t?", "+t:a})`,We=(e,l,o)=>{if(se(e)&&se(l))return D(a);const[r,d,$,i,u,I,b,w,h,g]=Y(),C=`./${H(o)}.d`,T=H(o,1),v=H(T),R=[],m=k(),p=l=>oe(e,((e,t)=>l(t,x(m,t,(()=>{const e=H(t,1);return[$(e+"Table",`{[rowId: Id]: ${e}Row}`,`${ce} the '${t}' Table`),$(e+"Row",`{${q(y(t,((e,l,t)=>`'${e}'${V(t)?"?":a}: ${l};`))," ")}}`,Ve(t)),$(e+"RowWhenSet",`{${q(y(t,((e,a)=>`'${e}'?: ${a};`))," ")}}`,Ve(t,1)),$(e+"CellId",q(y(t,(e=>`'${e}'`))," | "),`A Cell Id for the '${t}' Table`),$(e+"CellCallback",`(...[cellId, cell]: ${q(y(t,((e,a)=>`[cellId: '${e}', cell: ${a}]`))," | ")})${be}`,me(`a Cell Id and value from a Row in the '${t}' Table`)),$(e+"RowCallback",`(rowId: Id, forEachCell: (cellCallback: ${e}CellCallback)${be})${be}`,me(`a Row Id from the '${t}' Table, and a Cell iterator`))]})),H(t,1),I(K(t),`'${t}'`)))),y=(a,l)=>oe(e[a],((e,a)=>l(a,e[s],e[n],I(K(a),`'${a}'`),H(a,1)))),S=e=>oe(l,((a,l)=>e(l,a[s],a[n],I(K(l),`'${l}'`),H(l,1))));if(d(1,C,T,`create${T} as create${T}Decl`),!se(e)){const e=$("Tables",`{${q(p(((e,a)=>`'${e}'?: ${a[0]};`))," ")}}`,Te(4,1)),l=$("TableId",q(p((e=>`'${e}'`))," | "),"A Table Id in "+re),o=$("TableCallback",`(...[tableId, rowCallback]: ${q(p(((e,a)=>`[tableId: '${e}', forEachRow: (rowCallback: ${a[5]})${be}]`))," | ")})${be}`,me("a Table Id, and a Row iterator")),r=$("GetCellChange",`(...[tableId, rowId, cellId]: ${q(p(((e,a)=>`[tableId: '${e}', rowId: Id, cellId: ${a[3]}]`))," | ")}) => CellChange`,de+" returning information about any Cell's changes during a transaction"),u=$("TablesListener",`(${v}: ${T}, getCellChange: ${r}${ue})${be}`,pe(1)),b=$("TableIdsListener",`(${v}: ${T})${be}`,pe(2)),w=$("TableListener",`(${v}: ${T}, tableId: ${l}, getCellChange: ${r}${ue})${be}`,pe(3)),h=$("RowIdsListener",`(${v}: ${T}, tableId: ${l})`+be,pe(4,3)),g=$("RowListener",`(${v}: ${T}, tableId: ${l}, rowId: Id, getCellChange: ${r}${ue})${be}`,pe(5,3)),m=$("CellIdsListener",`(${v}: ${T}, tableId: ${l}, rowId: Id)`+be,pe(6,5)),S=$("CellListener",`(...[${v}, tableId, rowId, cellId, newCell, oldCell, getCellChange]: ${q(B(p((e=>y(e,((a,l)=>`[${v}: ${T}, tableId: '${e}', rowId: Id, cellId: '${a}', newCell: ${l}${ue}, oldCell: ${l}${ue}, getCellChange: ${r} | undefined]`)))))," | ")})${be}`,pe(7,5)),J=$("InvalidCellListener",`(${v}: ${T}, tableId: Id, rowId: Id, cellId: Id, invalidCells: any[])${be}`,pe(8));i("hasTables",a,t,Ge("hasTables"),Re("any Table")),i("getTables",a,e,Ge("getTables"),Te(0,1)),i("setTables","tables: "+e,T,ze("setTables","tables"),Te(1,1)),i("delTables",a,T,ze("delTables"),Te(3,1)),i("getTableIds",a,l+"[]",Ge("getTableIds",a,l+"[]"),ve("Table",re)),i("forEachTable","tableCallback: "+o,"void",Ge("forEachTable","tableCallback as any"),fe("Table",re));const O=k();p(((e,[l,o,s,n,r,$],u,I)=>{d(1,C,l,o,s,n,r,$),i(`has${u}Table`,a,t,Ge("hasTable",I),Re(ye(e))),i(`get${u}Table`,a,l,Ge("getTable",I,l),Ee(e)),i(`set${u}Table`,"table: "+l,T,ze("setTable",I+", table"),Ee(e,1)),i(`del${u}Table`,a,T,ze("delTable",I),Ee(e,3)),i(`get${u}RowIds`,a,"Ids",Ge("getRowIds",I),ve("Row",ye(e))),i(`get${u}SortedRowIds`,`cellId?: ${n}, descending?: boolean, offset?: number, limit?: number`,"Ids",Ge("getSortedRowIds",I+", cellId, descending, offset, limit"),ve("Row",ye(e),1)),i(`forEach${u}Row`,"rowCallback: "+$,"void",Ge("forEachRow",I+", rowCallback as any"),fe("Row",ye(e))),i(`has${u}Row`,"rowId: Id",t,Ge("hasRow",I+", rowId"),Re(he,ye(e))),i(`get${u}Row`,"rowId: Id",o,Ge("getRow",I+", rowId",o),Oe(e)),i(`set${u}Row`,"rowId: Id, row: "+s,T,ze("setRow",I+", rowId, row"),Oe(e,1)),i(`add${u}Row`,"row: "+s,"Id"+ue,Ge("addRow",I+", row"),"Adds a new Row to "+ye(e)),i(`set${u}PartialRow`,"rowId: Id, partialRow: "+s,T,ze("setPartialRow",I+", rowId, partialRow"),Oe(e,2)),i(`del${u}Row`,"rowId: Id",T,ze("delRow",I+", rowId"),Oe(e,3)),i(`get${u}CellIds`,"rowId: Id",n+"[]",Ge("getCellIds",I+", rowId",n+"[]"),ve("Cell",Se(e))),i(`forEach${u}Cell`,"rowId: Id, cellCallback: "+r,"void",Ge("forEachCell",I+", rowId, cellCallback as any"),fe("Cell",Se(e))),y(e,((l,o,s,n,r)=>{const d="Map"+H(o,1);j(O,o,d),i(`has${u}${r}Cell`,"rowId: Id",t,Ge("hasCell",`${I}, rowId, ${n}`),Re(ke(l),Se(e)));const $=`${o}${V(s)?ue:a}`;i(`get${u}${r}Cell`,"rowId: Id",$,Ge("getCell",`${I}, rowId, ${n}`,$),je(e,l)),i(`set${u}${r}Cell`,`rowId: Id, cell: ${o} | ${d}`,T,ze("setCell",`${I}, rowId, ${n}, cell as any`),je(e,l,1)),i(`del${u}${r}Cell`,"rowId: Id",T,ze("delCell",`${I}, rowId, ${n}`),je(e,l,3))}))})),i("getTablesJson",a,"Json",Ge("getTablesJson"),Te(5,1)),i("setTablesJson","tablesJson: Json",T,ze("setTablesJson","tablesJson"),Te(6,1)),i("addTablesListener",`${ie}: ${u}, mutator?: boolean`,"Id",Fe("addTablesListener",a,"mutator"),Te(7,1)+" changes"),i("addTableIdsListener",`${ie}: ${b}, mutator?: boolean`,"Id",Fe("addTableIdsListener",a,"mutator"),Le("the Table Ids",re,1)),i("addTableListener",`tableId: ${l} | null, ${ie}: ${w}, mutator?: boolean`,"Id",Fe("addTableListener","tableId","mutator"),Le("a Table",re)),i("addRowIdsListener",`tableId: ${l} | null, ${ie}: ${h}, mutator?: boolean`,"Id",Fe("addRowIdsListener","tableId","mutator"),Le("the Row Ids","a Table",1)),i("addRowListener",`tableId: ${l} | null, rowId: IdOrNull, ${ie}: ${g}, mutator?: boolean`,"Id",Fe("addRowListener","tableId, rowId","mutator"),Le("a Row","a Table")),i("addCellIdsListener",`tableId: ${l} | null, rowId: IdOrNull, ${ie}: ${m}, mutator?: boolean`,"Id",Fe("addCellIdsListener","tableId, rowId","mutator"),Le("the Cell Ids","a Row",1)),i("addCellListener",`tableId: ${l} | null, rowId: IdOrNull, cellId: ${q(p(((e,a)=>a[3]))," | ")} | null, ${ie}: ${S}, mutator?: boolean`,"Id",Fe("addCellListener","tableId, rowId, cellId","mutator"),Le("a Cell","a Row")),i("addInvalidCellListener",`tableId: IdOrNull, rowId: IdOrNull, cellId: IdOrNull, ${ie}: ${J}, mutator?: boolean`,"Id",Fe("addInvalidCellListener","tableId, rowId, cellId","mutator"),Ie+" whenever an invalid Cell change was attempted"),E(O,((e,a)=>$(a,`(cell: ${e}${ue}) => ${e}`,`Takes a ${e} Cell value and returns another`))),d(1,C,e,l,o,u,b,w,h,g,m,S,J,...L(O)),d(0,"tinybase","CellChange"),c(R,".setTablesSchema({",B(p(((e,l,t,o)=>[`[${o}]: {`,...y(e,((e,l,t,o)=>`[${o}]: {[${I(K(s),`'${s}'`)}]: ${I(K(l),`'${l}'`)}${V(t)?a:`, [${I(K(n),`'${n}'`)}]: ${f(t)?I(K(t),`'${t}'`):t}`}},`)),"},"]))),"})")}if(!se(l)){const e=$("Values",`{${q(S(((e,l,t)=>`'${e}'${V(t)?"?":a}: ${l};`))," ")}}`,Te(4,2)),l=$("ValuesWhenSet",`{${q(S(((e,a)=>`'${e}'?: ${a};`))," ")}}`,Te(4,2,1)),o=$("ValueId",q(S((e=>`'${e}'`))," | "),"A Value Id in "+re),r=$("ValueCallback",`(...[valueId, rowCallback]: ${q(S(((e,a)=>`[valueId: '${e}', value: ${a}]`))," | ")})${be}`,me("a Value Id, and value")),u=$("GetValueChange",`(valueId: ${o}) => ValueChange`,de+" returning information about any Value's changes during a transaction"),b=$("ValuesListener",`(${v}: ${T}, getValueChange: ${u}${ue})`+be,pe(9)),w=$("ValueIdsListener",`(${v}: ${T})${be}`,pe(10)),h=$("ValueListener",`(...[${v}, valueId, newValue, oldValue, getValueChange]: ${q(S(((e,a)=>`[${v}: ${T}, valueId: '${e}', newValue: ${a}${ue}, oldValue: ${a}${ue}, getValueChange: ${u} | undefined]`))," | ")})${be}`,pe(11)),g=$("InvalidValueListener",`(${v}: ${T}, valueId: Id, invalidValues: any[])${be}`,pe(12));i("hasValues",a,t,Ge("hasValues"),Re("any Value")),i("getValues",a,e,Ge("getValues",a,e),Te(0,2)),i("setValues","values: "+l,T,ze("setValues","values"),Te(1,2)),i("setPartialValues","partialValues: "+l,T,ze("setPartialValues","partialValues"),Te(2,2)),i("delValues",a,T,ze("delValues"),Te(3,2)),i("getValueIds",a,o+"[]",Ge("getValueIds",a,o+"[]"),ve("Value",re)),i("forEachValue","valueCallback: "+r,"void",Ge("forEachValue","valueCallback as any"),fe("Value",re)),S(((e,l,o,s,n)=>{i(`has${n}Value`,a,t,Ge("hasValue",s),Re(Je(e))),i(`get${n}Value`,a,l,Ge("getValue",s,l),xe(e)),i(`set${n}Value`,"value: "+l,T,ze("setValue",s+", value"),xe(e,1)),i(`del${n}Value`,a,T,ze("delValue",s),xe(e,3))})),i("getValuesJson",a,"Json",Ge("getValuesJson"),Te(5,2)),i("setValuesJson","valuesJson: Json",T,ze("setValuesJson","valuesJson"),Te(6,2)),i("addValuesListener",`${ie}: ${b}, mutator?: boolean`,"Id",Fe("addValuesListener",a,"mutator"),Te(7,2)+" changes"),i("addValueIdsListener",`${ie}: ${w}, mutator?: boolean`,"Id",Fe("addValueIdsListener",a,"mutator"),Le("the Value Ids",re,1)),i("addValueListener",`valueId: ${o} | null, ${ie}: ${h}, mutator?: boolean`,"Id",Fe("addValueListener","valueId","mutator"),Le("a Value",re)),i("addInvalidValueListener",`valueId: IdOrNull, ${ie}: ${g}, mutator?: boolean`,"Id",Fe("addInvalidValueListener","valueId","mutator"),Ie+" whenever an invalid Cell change was attempted"),d(1,C,e,l,o,r,b,w,h,g),d(0,"tinybase","ValueChange"),c(R,".setValuesSchema({",S(((e,l,t,o)=>[`[${o}]: {[${I(K(s),`'${s}'`)}]: ${I(K(l),`'${l}'`)}${V(t)?a:`, [${I(K(n),`'${n}'`)}]: ${f(t)?I(K(t),`'${t}'`):t}`}},`])),"})")}d(0,"tinybase",...Ne);const J=$("TransactionListener",`(${v}: ${T}, cellsTouched: boolean, valuesTouched: boolean)${be}`,de+" listening to the completion of a transaction");return i("getJson",a,"Json",Ge("getJson"),Te(5)),i("setJson","json: Json",T,ze("setJson","json"),Te(6)),i("transaction","actions: () => Return, doRollback?: DoRollback","Return",Ge("transaction","actions, doRollback"),"Execute a transaction to make multiple mutations","<Return>"),i("startTransaction",a,T,ze("startTransaction"),"Explicitly starts a transaction"),i("finishTransaction","doRollback?: DoRollback,",T,ze("finishTransaction","doRollback"),"Explicitly finishes a transaction"),i("addWillFinishTransactionListener",`${ie}: ${J}`,"Id",Fe("addWillFinishTransactionListener"),`${Ie} just before ${we}`),i("addDidFinishTransactionListener",`${ie}: ${J}`,"Id",Fe("addDidFinishTransactionListener"),`${Ie} just after ${we}`),i("callListener",ie+"Id: Id",T,ze("callListener",ie+"Id"),`Manually provoke a ${ie} to be called`),i("delListener",ie+"Id: Id",T,ze("delListener",ie+"Id"),`Remove a ${ie} that was previously added to ${re}`),i("getStore",a,"Store","store",Ae[0]+" the underlying Store object"),d(1,"tinybase","createStore",...Ne),d(1,C,T,`create${T} as create${T}Decl`,J),I("store",["createStore()",...R]),u("fluent","actions: () => Store",["actions();",`return ${v};`]),u("proxy",ie+": any",`(_: Store, ...args: any[]) => ${ie}(${v}, ...args)`),I(v,["{",...h(1),"}"]),[r(...b(0),...w(),`${$e} interface ${T} {`,...h(0),"}",a,X(`Creates a ${T} object`),`${$e} function create${T}(): ${T};`),r(...b(1),`${$e} const create${T}: typeof create${T}Decl = () => {`,...g(),`return Object.freeze(${v});`,"};")]};var Me=Object.defineProperty,Ze=Object.getOwnPropertySymbols,_e=Object.prototype.hasOwnProperty,Qe=Object.prototype.propertyIsEnumerable,Ue=(e,a,l)=>a in e?Me(e,a,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[a]=l,qe=(e,a)=>{for(var l in a||(a={}))_e.call(a,l)&&Ue(e,l,a[l]);if(Ze)for(var l of Ze(a))Qe.call(a,l)&&Ue(e,l,a[l]);return e},Be=(e,a,l)=>new Promise(((t,o)=>{var s=e=>{try{r(l.next(e))}catch(e){o(e)}},n=e=>{try{r(l.throw(e))}catch(e){o(e)}},r=e=>e.done?t(e.value):Promise.resolve(e.value).then(s,n);r((l=l.apply(e,a)).next())}));const He={parser:"typescript",singleQuote:!0,trailingComma:"all",bracketSpacing:!1,jsdocSingleLineComment:!1},Ke=ne((e=>{const a=()=>{const a=g(e.getTablesSchemaJson());return!se(a)||r(e.getTableIds(),(l=>{const t=e.getRowIds(l),o=k();if(r(t,(a=>r(e.getCellIds(l,a),(t=>{const s=e.getCell(l,a,t),n=x(o,t,(()=>[m(s),k(),[0],0])),[r,d,[$]]=n,i=x(d,s,(()=>0))+1;return i>$&&(n[2]=[i,s]),j(d,s,i),n[3]++,r==m(s)})))))return a[l]={},y(o,(([e,,[,o],r],d)=>{a[l][d]=qe({[s]:e},r==u(t)?{[n]:o}:{})})),1}))?a:{}},l=()=>{const a=g(e.getValuesSchemaJson());return se(a)&&e.forEachValue(((e,l)=>{a[e]={[s]:m(l)}})),a},t=e=>We(a(),l(),e),o=e=>Be(void 0,null,(function*(){let a;try{a=(yield import("prettier")).format}catch(e){a=e=>e}return i(t(e),(e=>Q(a(e,He))))}));return le({getStoreStats:a=>{let l=0,t=0,o=0;const s={};return e.forEachTable(((e,n)=>{l++;let r=0,d=0;const $={};n(((e,l)=>{r++;let t=0;l((()=>t++)),d+=t,a&&($[e]={rowCells:t})})),t+=r,o+=d,a&&(s[e]={tableRows:r,tableCells:d,rows:$})})),qe({totalTables:l,totalRows:t,totalCells:o,totalValues:u(e.getValueIds()),jsonLength:U(e.getJson())},a?{detail:{tables:s}}:{})},getStoreTablesSchema:a,getStoreValuesSchema:l,getStoreApi:t,getPrettyStoreApi:o,getStore:()=>e})}));exports.createTools=Ke;
